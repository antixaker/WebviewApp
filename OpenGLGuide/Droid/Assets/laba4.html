<html>
<body>
<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="labstyles.css" type="text/css">
</head>
  <div id="main" bgcolor="#c0dbe4">
  
  <p><strong>Лабораторная работа №4</strong>
</p>
<p><strong>Тема</strong>: Растровые и векторные примитивы. Алгоритмы генерации векторных примитивов
</p>
<p><strong>Цель работы:</strong> Анализ различных алгоритмов генерации отрезков на прямоугольном растре.
</p>
<p><strong>Теоретический материал.</strong>
</p>
<p>Одним из графических примитивов в двумерной графике является отрезок прямой линии, задаваемый координатами своих концевых точек. Отображение таких отрезков в растровой графике отнюдь не просто. Связано это с тем, что изображение отрезка на прямоугольном растре является совокупностью горизонтальных, либо вертикальных отрезков и отдельных точек рис. 4.1.
</p>
<p>Задачей алгоритма генерации отрезков прямых линий является определение координат пикселей, которые необходимо подсветить для получения изображения заданного отрезка. Существует несколько алгоритмов генерации отрезков. Эти алгоритмы выбирают пиксели так, чтобы их координаты были наиболее близки к координатам точек, принадлежащих реальному отрезку. Наибольшее распространение в компьютерной графике получили инкрементные алгоритмы генерации отрезков. В этих алгоритмах, отрезок рисуется последовательно пиксель за пикселем. Координаты
</p>
<p>следующего пикселя определяются исходя из координат текущего, и некоторой дополнительной информации. Рассмотрим два инкрементных алгоритма.
</p>
<p><br>
</p>
<p>Рис. 4. 1 Растровое представление отрезков прямых линий
</p>
<p><strong><em>Алгоритм 1 Цифровой дифференциальный анализатор</em></strong>
</p>
<p>Алгоритм <strong>Цифровой дифференциальный анализатор</strong> (англ. DDA - Digital Differential Analyzer) строит 8-связную линию.
</p>
<p>Для начала, пусть P<sub>1</sub> = (1, 0) ; P<sub>2</sub> = (1, 1). Для определения того, какой из пикселей, - P<sub>1</sub> или P<sub>2</sub>, - следует закрасить, сравним расстояния до них. В силу подобия треугольников, образованных пересечением рисуемого отрезка, прямой x = 1 и перпендикулярами из P<sub>1</sub> и P<sub>2</sub> на отрезок (см. рис.4.2), достаточно сравнить e (ординату пересечения отрезка c прямой x = 1 ) с . Далее, для следующего шага алгоритм работает аналогично с учетом изменения e - ординаты пересечения отрезка со следующей вертикальной прямой .
</p>
<p><br>
</p>
<p>Рис. 4. 2 Цифровой дифференциальный анализатор.
</p>
<p>// Координаты концов отрезка - (0,0) и (a,b)
</p>
<p><br>
</p>
<p>e = b/a; // Текущая ордината
</p>
<p>delta_e = b/a; // Приращение ординаты
</p>
<p><br>
</p>
<p>// (x,y) - Координаты текущей точки
</p>
<p>x = 0; y = 0;
</p>
<p><br>
</p>
<p>while( x &lt; a )
</p>
<p>{
</p>
<p> рисуем пиксель с координатами(x, y);
</p>
<p><br>
</p>
<p> if( e &gt; 1/2 )
</p>
<p> {
</p>
<p> // d : диагональное смещение
</p>
<p> x++; y++;
</p>
<p><br>
</p>
<p> // т.к. произошло смещение по y на 1 вверх
</p>
<p> e += delta_e - 1;
</p>
<p> }
</p>
<p> else
</p>
<p> {
</p>
<p> // s : горизонтальное смещение
</p>
<p> x++;
</p>
<p> e += delta_e;
</p>
<p> }
</p>
<p>}
</p>
<p>Листинг4.1. Цифровой дифференциальный анализатор
</p>
<p>Недостатком данного алгоритма является то, что он работает с числами с плавающей точкой.
</p>
<p><strong><em>Алгоритм 2 Несимметричный цифровой дифференциальный анализатор (несимметричный ЦДА)</em></strong>
</p>
<p>В основу работы этого алгоритма положен тот факт, что производная функции, представляющей прямую линию на плоскости, является величиной постоянной, т.е. . Если у нас имеется отрезок прямой, заданный координатами своих концевых точек (x<sub>1</sub>, y<sub>1</sub>) и (x<sub>2</sub>, y<sub>2</sub> ), то величину этой производной можно рассчитать следующим образом: .
</p>
<p>Алгоритм «несимметричный ЦДА» использует эту величину, чтобы рассчитать значение смещения по одной из координат, при смещении по другой на 1. Этот алгоритм можно описать следующей последовательностью действий (подразумевается, что хотя бы одно из значений Δx или Δy не равно нулю).
</p>
<ul>
	<li>Рассчитаем величину d и определим, ось, вдоль которой будем продвигаться, следующим образом:</li>
</ul>
<p>Если Δx = 0 , то наш отрезок является вертикальным, тогда d = 0, продвигаться будем вдоль оси y .
</p>
<p>Если Δy = 0, то наш отрезок является горизонтальным, тогда d = 0 , и продвигаться будем вдоль оси x .
</p>
<p>Если Δx ≥Δy , тогда, d=продвигаться будем вдоль оси x .
</p>
<p>В противном случае, d=и продвигаться будем вдоль оси y .
</p>
<ul>
	<li>Подсветим пиксель с координатами (x<sub>1</sub>, y<sub>1</sub>).</li>
	<li>Увеличим координату, соответствующую оси, вдоль которой продвигаемся, на 1<br> (-1), а другую на d , и подсветим пиксель, соответствующий этим координатам.</li>
	<li>Повторять пункт 3, до тех пор, пока не нарисуем весь отрезок.</li>
</ul>
<p>Рассмотрим работу алгоритма на следующих примерах рис. 4.3.
</p>
<p><br>
</p>
<p>Рис. 4. 3 Генерация отрезков несимметричным ЦДА.
</p>
<p><br>
</p>
<p><strong><em>Отрезок а): x<sub>1</sub>=3, y<sub>1</sub>=1, x<sub>2</sub>=1, y<sub>2</sub>=8</em></strong>
</p>
<ul>
	<li>Поскольку Δy &gt;Δx, то d=, продвигаться будем вдоль оси y.</li>
	<li>Подсветим пиксель с координатами (3, 1).</li>
	<li>Увеличим y<sub>1</sub> на 1, а x<sub>1</sub> на . Получим y<sub>1</sub>=2, x<sub>1</sub>=. Подсветим пиксель с координатами (3 (),2). </li>
	<li>Далее повторяем пункт 3, пока не нарисуем весь отрезок. </li>
</ul>
<p>На следующем шаге получим y<sub>1</sub>=3, x<sub>1</sub>=. Подсветим пиксель с координатами (3, 2). Далее получим y<sub>1</sub>=4, x<sub>1</sub>=. Подсветим пиксель с координатами (4, 2) и т.д.
</p>
<p><strong><em>Отрезок б): x<sub>1</sub>=7, y<sub>1</sub>=1, x<sub>2</sub>=13, y<sub>2</sub>=4.</em></strong>
</p>
<ul>
	<li>Поскольку Δx &gt;Δy, то d= , продвигаться будем вдоль оси x.</li>
	<li>Подсветим пиксель с координатами (7, 1).</li>
	<li>Увеличим x<sub>1</sub> на 1, а y<sub>1</sub> на 0,5. Получим y<sub>1</sub>=1,5, x<sub>1</sub>=8 . Подсветим пиксель с координатами (8, 2(1,52)). </li>
	<li>Далее повторяем пункт 3, пока не нарисуем весь отрезок. </li>
</ul>
<p>На следующем шаге получим y<sub>1</sub>=2, x<sub>1</sub>=9. Подсветим пиксель с координатами (9, 2). Далее получим y<sub>1</sub>=2,5, x<sub>1</sub>=10. Подсветим пиксель с координатами (10, 3) и т.д.
</p>
<p><strong><em>Алгоритм 3 Алгоритм Брезенхема</em></strong>
</p>
<p>Рассмотренный выше алгоритм неудобен тем, что в общем случае нам приходится использовать вещественные переменные и операцию деления, что отрицательно сказывается на его быстродействии. Однако можно разработать такой алгоритм генерации отрезков, в котором будет использоваться только целочисленная арифметика, и не будет операций деления и умножения. Быстродействие такого алгоритма также возрастет. Данный алгоритм получил название «алгоритм Брезенхема» по фамилии его автора.
</p>
<p>Будем разрабатывать алгоритм нахождения координат точек между A и B использующий вещественные числа, но таким образом, что это ограничение потом можно будет легко устранить, и использовать только целочисленные переменные. Для этого выполним следующие операции.
</p>
<p>Начнем рисовать отрезок с точки А( <strong><em>A<sub>x</sub>, A<sub>y</sub></em></strong> ). В цикле будем задавать приращение 1 для переменной <strong><em>A<sub>y</sub></em></strong> и будем оставлять <strong><em>A<sub>x</sub></em></strong> либо неизменным, либо также увеличивать на 1. При этом последний выбор будем осуществлять так, чтобы новая точка сетки ( <strong><em>A<sub>x</sub>, A<sub>y</sub></em></strong> ) располагалась как можно ближе к прямой линии, проходящей через точки А и B рис. 4.4.
</p>
<p><br>
</p>
<p>Рис. 4. 4 Пример отрезка
</p>
<p>Это означает, что расстояние по горизонтали между новой выбранной точкой и этой линией не должно превышать значения 0,5.
</p>
<p>Введем переменную d для обозначения этого расстояния. Потребуем, чтобы .
</p>
<p>Последнее неравенство обеспечивает условие для определения необходимости давать приращение переменной <strong><em>A<sub>x</sub></em></strong> .
</p>
<p>Теперь можно написать первый вариант реализации алгоритма нахождения координат точек между A и В:
</p>
<ul>
	<li>Установим значения для переменных d и t: d = 0, t=.</li>
	<li>Подсветим пиксель с координатами ( <strong><em>Ax, Ay</em></strong> ).</li>
	<li>Увеличим d на величину t, а <strong><em>A<sub>y</sub></em></strong> на 1 (-1).</li>
	<li>Если d &gt; 0,5 , то увеличим <strong><em>A<sub>x</sub></em></strong> на 1, и вычтем 1 из d.</li>
	<li>Будем повторять пункты 2-4, пока не нарисуем весь отрезок.</li>
</ul>
<p>Отклонение, вначале устанавливается равным нулю и изменяется на каждом шаге. Поскольку оно показывает, насколько левее точной прямой линии лежит вычисленная точка, то значение <strong><em>d</em></strong> увеличивается на значение <strong><em>t</em></strong>, если y увеличивается на 1 и x остается без изменения. Это условие не выполняется, если значение <strong><em>d</em></strong> превышает 0,5. В этот момент нужно увеличить значение <strong><em>x</em></strong> на 1. Соответственно, и отклонение <strong><em>d</em></strong> должно быть уменьшено на единицу.
</p>
<p>Теперь посмотрим, как можно избавиться от вещественных значений переменных t и d и постоянной 0,5.
</p>
<p>Значение переменной t вычисляется следующим образом:
</p>
<p><br>
</p>
<p>где числитель и знаменатель представляют собой целые числа.
</p>
<p>Величина <strong><em>d</em></strong> вычисляется как конечная сумма элементов, каждый из которых равен либо t, либо -1. Поэтому <strong><em>d</em></strong> также можно записать в виде частного со знаменателем равным <strong><em>A<sub>y</sub> - B<sub>y</sub></em></strong> .
</p>
<p>Значит, можно перейти к целочисленным переменным <strong><em>t</em></strong> и <strong><em>d</em></strong>, путем умножения на значение знаменателя. Также просто избавиться от константы 0,5. Для этого нужно дополнительно умножить значение знаменателя на 2. Эта операция может быть заменена простым поразрядным сдвигом на 1 бит влево. Таким образом t = 2Δx , где Δx = A<sub>x</sub> - B<sub>x</sub> .
</p>
<p>Напишем новый вариант реализации нашего алгоритма.
</p>
<ul>
	<li>Установим значения для переменных <strong><em>d, t</em></strong> <strong><em>и Δ</em></strong>: <strong><em>d</em></strong> = 0 , <strong><em>t</em></strong> = 2Δx = 2(<strong><em>A<sub>x</sub></em></strong> - <strong><em>B<sub>x</sub></em></strong>), <br><strong><em>Δ =</em></strong> 2Δy = 2(<strong><em>A<sub>y</sub></em></strong> <strong><em>- B<sub>y</sub></em></strong>) .</li>
	<li>Подсветим пиксель с координатами ( <strong><em>A<sub>x</sub>, A<sub>y</sub></em></strong> ).</li>
	<li>Увеличим d на величину<strong><em> t</em></strong>, а <strong><em>A<sub>y</sub></em></strong>на 1.</li>
	<li>Если <strong><em>d &gt; Δy</em></strong> , то увеличим Ax на 1, и вычтем <strong><em>Δ</em></strong> из <strong><em>d</em></strong>.</li>
	<li>Будем повторять пункты 2-4, пока не нарисуем весь отрезок.</li>
</ul>
<p>Однако наша функция будет правильно работать только для того случая, который изображен на рис. 4.4. Для того, чтобы алгоритм правильно работал для любого отрезка, его необходимо дополнить. В результате получим следующий алгоритм:
</p>
<ul>
	<li>Отсортируем вершины А и В так, чтобы выполнялось условие <strong><em>A<sub>y</sub> ≤ B<sub>y</sub></em></strong> .</li>
	<li>Рассчитаем значения <strong><em>Δx = B<sub>x</sub> - A<sub>x</sub></em></strong> , и <strong><em>Δy = B<sub>y</sub> - A<sub>y</sub></em></strong> .</li>
	<li>Если <strong><em>Δx ≥ 0</em></strong> , то установим значение dx =1, иначе: dx = -1, и изменим знак у Δx на противоположный.</li>
	<li>Установим <strong><em>d = 0</em></strong> . Если <strong><em>Δy ≥ Δx</em></strong> , то установим <strong><em>t = 2Δx</em></strong> , <strong><em>Δ= 2Δy</em></strong> . Иначе<strong><em> t = 2Δy</em></strong>, <strong><em>Δ= 2Δx</em></strong> . (операцию умножения на 2 везде заменяем поразрядным сдвигом влево на 1 бит).</li>
	<li>Если <strong><em>Δy ≥Δx</em></strong> , то перейти к пункту 6, иначе к пункту 11.</li>
	<li>Подсветим пиксель с координатами ( <strong><em>A<sub>x</sub>, A<sub>y</sub></em></strong> ).</li>
	<li>Увеличим <strong><em>A<sub>y</sub></em></strong> на 1, а d на величину t.</li>
	<li>Если <strong><em>d &gt; Δy</em></strong> , то увеличить <strong><em>A<sub>x</sub></em></strong> на величину <strong><em>dx</em></strong> , и вычесть величину<strong><em> Δ</em></strong> из <strong><em>d</em></strong> .</li>
	<li>Повторять пункты 6-8, пока не нарисуем весь отрезок.</li>
	<li>Завершить выполнение алгоритма.</li>
	<li>Подсветим пиксель с координатами ( <strong><em>A<sub>x</sub>, A<sub>y</sub></em></strong> ).</li>
	<li>Увеличим <strong><em>A<sub>x</sub></em></strong> на 1, а <strong><em>d</em></strong> на величину <strong><em>t</em></strong> .</li>
	<li>Если <strong><em>d &gt; Δx</em></strong> , то увеличить <strong><em>A<sub>y</sub></em></strong> на 1, и вычесть величину<strong><em> Δ</em></strong> из <strong><em>d</em></strong> .</li>
	<li>Повторять пункты 6-8, пока не нарисуем весь отрезок.</li>
	<li>Завершить выполнение алгоритма.</li>
</ul>
<p>При построении растрового образа отрезка необходимо, прежде всего, установить критерии "хорошей" аппроксимации. Первое требование состоит в том, что отрезок должен начинаться и кончаться в заданных точках и при этом выглядеть сплошным и прямым (при достаточно высоком разрешении дисплея этого можно добиться). Кроме того, яркость вдоль отрезка должна быть одинаковой и не зависеть от наклона отрезка и его длины. Это требование выполнить сложнее, поскольку горизонтальные и вертикальные отрезки всегда будут ярче наклонных, а постоянная яркость вдоль отрезка опять же достигается на вертикальных, горизонтальных и наклоненных под углом в 45 линиях. И, наконец, алгоритм должен работать быстро. Для этого необходимо по возможности исключить операции с вещественными числами. С целью ускорения работы алгоритма можно также реализовать его на аппаратном уровне.
</p>
<p><br>
</p>
<p>Рис. 4. 5 Растровый образ отрезка
</p>
<p>В большинстве алгоритмов используется пошаговый метод изображения, т.е. для нахождения координат очередной точки растрового образа наращивается значение одной из координат на единицу растра и вычисляется приращение другой координаты.
</p>
<p>Задача состоит в построении отрезка, соединяющего на экране точки с координатами (будем считать, что ). Для построения отрезка прямой на плоскости с вещественными координатами можно воспользоваться уравнением прямой, проходящей через две заданные точки, которое имеет вид
</p>
<p><br>
</p>
<p>Теперь, считая, что - координаты текущей точки растрового образа, а - точное значение координаты точки отрезка, можно построить следующую точку:
</p>
<p><br>
</p>
<p>Следует заметить, что целочисленная координата изменится только в том случае, если y превысит величину ( есть ближайшее к целое число, полученное в результате операции округления). Приведенный пример включает операции с вещественными числами, которые выполняются существенно медленнее, чем соответствующие целочисленные операции, а при построении растрового образа отрезка желателен алгоритм, по возможности обращающийся только к целочисленной арифметике. Кроме того, алгоритм должен работать при любом взаимном расположении концов отрезка.
</p>
<p>Алгоритм Брезенхема построения растрового образа отрезка был изначально разработан для графопостроителей, но он полностью подходит и для растровых дисплеев. В процессе работы в зависимости от углового коэффициента отрезка наращивается на единицу либо , либо , а изменение другой координаты зависит от расстояния между действительным положением точки и ближайшей точкой растра (смещения). Алгоритм построен так, что анализируется лишь знак этого смещения.
</p>
<p><br>
</p>
<p>Рис. 4. 6 Связь углового коэффициента с выбором пикселя
</p>
<p>На рис. 4.4 это иллюстрируется для отрезка с угловым коэффициентом, лежащим в диапазоне от нуля до единицы. Из рисунка можно заметить, что если угловой коэффициент , то при выходе из точки пересечение с прямой будет ближе к прямой , чем к прямой . Следовательно, точка растра лучше аппроксимирует прохождение отрезка, чем точка . При верно обратное.
</p>
<p>На рис. 4.5 показано, каким образом строятся точки растра для отрезка с тангенсом угла наклона , а на рис. 4.6 - график смещения. В начале построения смещение полагается равным , а затем на каждом шаге оно наращивается на величину , и если при этом вертикальная координата точки растра увеличивается на единицу, то смещение в свою очередь уменьшается на единицу.
</p>
<p>На рис. 4.7 приведена блок-схема алгоритма для случая . Нетрудно понять, как от этого алгоритма перейти к целочисленному: достаточно вместо величины смещения перейти к величине .
</p>
<p><br>
</p>
<p>Рис. 4. 7 Пиксели, принадлежащие развертке отрезка
</p>
<p><br>
</p>
<p>Рис. 4. 8 График изменения отклонения
</p>
<p>Приведем общий алгоритм Брезенхема, который учитывает все возможные случаи направления отрезка, рассматриваемого как вектор на координатной плоскости (на рис. 4.9 выделены четыре области и указаны особенности алгоритма в каждой из них).
</p>
<p>В описании алгоритма используются следующие функции:
</p>
<p>swap (a, b): обмен значений переменных a, b;
</p>
<p>abs (a): абсолютное значение a;
</p>
<p>sign (a): 0, если a= 0, 1, если a&gt;0, –1, если a&lt;0;
</p>
<p>point (i, j) - инициализация точки (i, j).
</p>
<p>Предполагается, что концы отрезка не совпадают и что все используемые переменные являются целыми.
</p>
<p><br>
</p>
<p>Рис. 4. 9 Блок-схема одной ветви алгоритма Брезенхема
</p>
<p>i=i1;
</p>
<p>j=j1;
</p>
<p>di=i2-i1;
</p>
<p>dj=j2-j1;
</p>
<p>s1=sign(i2-i1);
</p>
<p>s2=sign(j2-j1);
</p>
<p>di=abs(di);
</p>
<p>dj=abs(dj);
</p>
<p>if (dj&gt;di)
</p>
<p>{
</p>
<p> swap(di,dj); c=1;
</p>
<p>}
</p>
<p>else c=0;
</p>
<p>e=2*dj-di;	// Инициализация смещения
</p>
<p>// Основной цикл
</p>
<p>for (l=0; l&lt;di; l++)
</p>
<p>{
</p>
<p>	point(i,j);
</p>
<p>	while (e&gt;=0)
</p>
<p>	{
</p>
<p>		if (c==1) i=i+s1;
</p>
<p>		else j=j+s2;
</p>
<p>		e=e-2*di;
</p>
<p>	}
</p>
<p>	if (c==1) j=j+s2; else i=i+s1;
</p>
<p>	e=e+2*dj;
</p>
<p>	}
</p>
<p><br>
</p>
<p>Рис. 4. 10  Четыре возможных направления отрезка
</p>
<p><br>
</p>
<p><strong>Задания.</strong>
</p>
<p>Все задания к лабораторной работе №4 необходимо выполнять, используя псевдопиксель, в виде закрашенного сплошным цветом квадрата размером n х n пикселей. Для выполнения заданий необходимо в первую очередь реализовать соответствующие алгоритмы генерации отрезков на используемом языке программирования. Затем, используя эти алгоритмы, выполнить соответствующий вариант задания.
</p>
<p><strong><em>При выполнении вариантов заданий ЗАПРЕЩАЕТСЯ пользоваться встроенными функциями рисования отрезков!</em></strong>
</p>
<p><strong><em></em></strong><br>
</p>
<table class="table table-responsive table-bordered table-hover">
<tbody>
<tr>
	<td>
		<p>Вариант
		</p>
	</td>
	<td>
		<p>Рисунок
		</p>
	</td>
</tr>
<tr>
	<td>
		<ul>
		</ul>
	</td>
	<td>
		<p>Нарисовать красным цветом наибольшее изображение икосаэдра, которое поместится в области вывода рисунка. Ребра икосаэдра, наиболее близкие к наблюдателю, (жирные линии) нарисовать, используя алгоритм
		</p>
		<p>несимметричный ЦДА и псевдопиксель размером 20х20 пикселей. Ребра дальние необходимо нарисовать, используя алгоритм Брезенхема и псевдопиксель размером 10х10 пикселей.
		</p>
		<p>Дополнительное задание: Добейтесь, чтобы размеры рисунка изменялись при изменении размеров области вывода (окна).
		</p>
		<p><br>
		</p>
	</td>
</tr>
<tr>
	<td>
		<ul>
		</ul>
	</td>
	<td>
		<p>На базе алгоритма ЦДА разработать алгоритм рисования пунктирной линии. Пунктирная линия состоит из отрезков, разделенных промежутками. Длина отрезка не может быть больше 10 псевдопикселей. Длина промежутка составляет половину длины отрезка. Линия начинается и заканчивается отрезком. Все отрезки и промежутки должны иметь примерно одинаковую длину. Используя алгоритм Брезенхема и псевдопиксель 20х20, нарисовать зеленым цветом наибольший прямоугольник, который поместится в области вывода. Диагонали прямоугольника провести пунктирной линией красного цвета, используя псевдопиксель 5х5.
		</p>
		<p>Дополнительное задание: Добейтесь, чтобы размеры рисунка изменялись при изменении размеров области вывода (окна).
		</p>
		<p><br>
		</p>
	</td>
</tr>
<tr>
	<td>
		<ul>
		</ul>
	</td>
	<td>
		<p>Нарисовать красным цветом наибольшее изображение куба, которое поместится в области вывода рисунка. Ребра куба наиболее близкие к наблюдателю (жирные линии) нарисовать, используя алгоритм Брезенхема и
		</p>
		<p>псевдопиксель размером 20х20 пикселей. Стороны дальние необходимо нарисовать, используя алгоритм несимметричный ЦДА и псевдопиксель размером 10х10 пикселей.
		</p>
		<p>Дополнительное задание: Добейтесь, чтобы размеры рисунка изменялись при изменении размеров области вывода (окна).
		</p>
		<p><br>
		</p>
	</td>
</tr>
<tr>
	<td>
		<ul>
		</ul>
	</td>
	<td>
		<p>Нарисовать зеленым цветом наибольшее изображение октаэдра, которое поместится в области вывода рисун-ка. Стороны октаэдра наиболее близкие к наблюдате-лю (жирные линии) нарисовать, используя алгоритм ЦДА и псевдопиксель размером 20х20 пикселей. Стороны дальние необходимо нарисо-вать, используя алгоритм Брезенхема и псевдопиксель размером 10х10 пикселей.
		</p>
		<p>Дополнительное задание: Добейтесь, чтобы размеры рисунка изменялись при изменении размеров области вывода (окна).
		</p>
		<p><br>
		</p>
	</td>
</tr>
<tr>
	<td>
		<ul>
		</ul>
	</td>
	<td>
		<p>Нарисовать наибольшую шестилучевую звезду, которая поместится в области вывода рисунка. Стороны верхнего треугольника необходимо нарисовать зеленым цветом, используя алгоритм несимметричный ЦДА и псевдопиксель размером 10х10 пикселей. Стороны нижнего треугольника необходимо нарисовать красным цветом, используя алгоритм Брезенхема и
		</p>
		<p>псевдопиксель размером 20х20 пикселей.
		</p>
		<p>Дополнительное задание: Добейтесь, чтобы размеры рисунка изменялись при изменении размеров области вывода (окна).
		</p>
		<p><br>
		</p>
	</td>
</tr>
<tr>
	<td>
		<ul>
		</ul>
	</td>
	<td>
		<p>Нарисовать наибольшую пятиконечную звезду, которая поместится в области вывода и пятиугольник внутри нее.. Звезду необходимо нарисовать красным цветом, используя алгоритм Брезенхема и псевдопиксель размером 20х20 пикселей. Пятиугольник нарисовать синим цветом алгоритмом ЦДА псевдопикселями размером 10х10 пикселей.
		</p>
		<p>Дополнительное задание Добейтесь, чтобы размеры рисунка изменялись при изменении размеров области вывода (окна).
		</p>
		<p><br>
		</p>
	</td>
</tr>
<tr>
	<td>
		<ul>
		</ul>
	</td>
	<td>
		<p>Нарисовать наибольший прямоугольник с соотношением сторон 2/3, который поместится в области вывода и построить все его диагонали. Прямоугольник расположить по центру экрана. Короткие стороны необходимо расположить параллельно горизонтальной стороне экрана. Прямоугольник необходимо нарисовать красным цветом, используя алгоритм несимметричный
		</p>
		<p>ЦДА и псевдопиксель размером 20х20 пикселей. Диагонали изобразить двумя различными цветами (зеленым и синим) алгоритмом Брезенхема псевдопикселями размером 10х10 пикселей.
		</p>
		<p>Дополнительное задание Добейтесь, чтобы размеры рисунка изменялись при изменении размеров области вывода (окна).
		</p>
		<p><br>
		</p>
	</td>
</tr>
<tr>
	<td>
		<ul>
		</ul>
	</td>
	<td>
		<p>Нарисовать наибольший правильный шестиугольник, который поместится в области вывода и построить все его диагонали. Стороны шестиугольника необходимо нарисовать оранжевым цветом, используя алгоритм ЦДА и псевдопиксель размером 20х20 пикселей. Диагонали изобразить тремя различными цветами (красным зеленым и синим) алгоритмом Брезенхема псевдопикселями размером 10х10 пикселей.
		</p>
		<p>Дополнительное задание Добейтесь, чтобы размеры рисунка изменялись при изменении размеров области вывода (окна).
		</p>
		<p><br>
		</p>
	</td>
</tr>
<tr>
	<td>
		<ul>
		</ul>
	</td>
	<td>
		<p>Нарисовать наибольший равносторонний треугольник, который поместится в области вывода. Одна из сторон треугольника должна идти вдоль нижней границы области вывода. Боковые стороны необходимо нарисовать красными линиями, используя алгоритм Брезенхема. Основание нарисовать зеленой линией алгоритмом несимметричного ЦДА. Размер псевдопикселя для всех отрезков составляет 20х20 пикселей.
		</p>
		<p>Дополнительное задание Добейтесь, чтобы размеры рисунка изменялись при изменении размеров области вывода (окна).
		</p>
		<p><br>
		</p>
	</td>
</tr>
<tr>
	<td>
		<ul>
		</ul>
	</td>
	<td>
		<p>Нарисовать красным цветом наибольшее изображение икосаэдра, которое поместится в области вывода ри-сунка. Ребра икосаэдра, наиболее близкие к наблюда-телю, (жирные линии) нарисовать, используя алгоритм
		</p>
		<p>ЦДА и псевдопиксель размером 20х20 пикселей. Ребра дальние необходимо нарисо-вать, используя алгоритм Брезенхема и псевдопиксель размером 10х10 пикселей.
		</p>
		<p>Дополнительное задание Добейтесь, чтобы размеры рисунка изменялись при изменении размеров области вывода (окна).
		</p>
		<p><br>
		</p>
	</td>
</tr>
<tr>
	<td>
		<ul>
		</ul>
	</td>
	<td>
		<p>На базе алгоритма несимметричный ЦДА разработать алгоритм рисования пунктирной линии. Пунктирная линия состоит из отрезков, разделенных промежутка-ми. Длина отрезка не может быть больше 10 псев-допикселей. Длина промежутка составляет половину длины отрезка. Линия начинается и заканчивается от-резком. Все отрезки и промежутки должны иметь при-мерно одинаковую длину. Используя алгоритм Бре-зенхема и псевдопиксель 20х20, нарисовать зеленым цветом наибольший прямоугольник, который поме-стится в области вывода. Диагонали прямоугольника провести пунктирной линией красного цвета, исполь-зуя псевдопиксель 5х5.
		</p>
		<p>Дополнительное задание: Добейтесь, чтобы размеры рисунка изменялись при изменении размеров области вывода (окна).
		</p>
		<p><br>
		</p>
		<p><br>
		</p>
	</td>
</tr>
<tr>
	<td>
		<ul>
		</ul>
	</td>
	<td>
		<p>Нарисовать красным цветом наибольшее изображение куба, которое поместится в области вывода рисунка. Ребра куба наиболее близкие к наблюдателю (жирные линии) нарисовать, используя алгоритм Брезенхема и
		</p>
		<p>псевдопиксель размером 20х20 пикселей. Стороны дальние необходимо нарисовать, используя алгоритм ЦДА и псевдопиксель размером 10х10 пикселей.
		</p>
		<p>Дополнительное задание: Добейтесь, чтобы размеры рисунка изменялись при изменении размеров области вывода (окна).
		</p>
		<p><br>
		</p>
	</td>
</tr>
<tr>
	<td>
		<ul>
		</ul>
	</td>
	<td>
		<p>Нарисовать зеленым цветом наибольшее изображение октаэдра, которое поместится в области вывода рисунка. Стороны октаэдра наиболее близкие к наблюдателю (жирные линии) нарисовать, используя алгоритм несимметричный ЦДА и псевдопиксель размером 20х20 пикселей. Стороны дальние необходимо нарисовать, используя алгоритм Брезенхема и псевдопиксель размером 10х10 пикселей.
		</p>
		<p>Дополнительное задание: Добейтесь, чтобы размеры рисунка изменялись при изменении размеров области вывода (окна).
		</p>
		<p><br>
		</p>
	</td>
</tr>
<tr>
	<td>
		<ul>
		</ul>
	</td>
	<td>
		<p>Нарисовать наибольшую шестилучевую звезду, кото-рая поместится в области вывода рисунка. Стороны верхнего треугольника необходимо нарисовать зеле-ным цветом, используя алгоритм ЦДА и псевдопиксель размером 10х10 пикселей. Стороны нижнего треугольника необходимо нарисовать красным цветом, используя алгоритм Брезенхема и
		</p>
		<p>псевдопиксель размером 20х20 пикселей.
		</p>
		<p>Дополнительное задание: Добейтесь, чтобы размеры рисунка изменялись при изменении размеров области вывода (окна).
		</p>
		<p><br>
		</p>
	</td>
</tr>
<tr>
	<td>
		<ul>
		</ul>
	</td>
	<td>
		<p>Нарисовать наибольшую пятиконечную звезду, кото-рая поместится в области вывода и пятиугольник внутри нее.. Звезду необходимо нарисовать красным цветом, используя алгоритм Брезенхема и псевдопик-сель размером 20х20 пикселей. Пятиугольник нарисо-вать синим цветом алгоритмом несимметричный ЦДА псевдопикселями размером 10х10 пикселей.
		</p>
		<p>Дополнительное задание Добейтесь, чтобы размеры рисунка изменялись при изменении размеров области вывода (окна).
		</p>
		<p><br>
		</p>
	</td>
</tr>
<tr>
	<td>
		<ul>
		</ul>
	</td>
	<td>
		<p>Нарисовать наибольший прямоугольник с соотноше-нием сторон 2/3, который поместится в области вывода и построить все его диагонали. Прямоугольник расположить по центру экрана. Короткие стороны необходимо расположить параллельно горизонтальной стороне экрана. Прямоугольник необходимо нарисовать красным цветом, используя алгоритм
		</p>
		<p>ЦДА и псевдопиксель размером 20х20 пикселей. Диа-гонали изобразить двумя различными цветами (зеле-ным и синим) алгоритмом Брезенхема псевдопикселя-ми размером 10х10 пикселей.
		</p>
		<p>Дополнительное задание Добейтесь, чтобы размеры рисунка изменялись при изменении размеров области вывода (окна).
		</p>
		<p><br>
		</p>
	</td>
</tr>
<tr>
	<td>
		<ul>
		</ul>
	</td>
	<td>
		<p>Нарисовать наибольший правильный шестиугольник, который поместится в области вывода и построить все его диагонали. Стороны шестиугольника необходимо нарисовать оранжевым цветом, используя алгоритм несимметричный ЦДА и псевдопиксель размером 20х20 пикселей. Диагонали изобразить тремя различ-ными цветами (красным зеленым и синим) алгоритмом Брезенхема псевдопикселями размером 10х10 пикселей.
		</p>
		<p>Дополнительное задание Добейтесь, чтобы размеры рисунка изменялись при изменении размеров области вывода (окна).
		</p>
		<p><br>
		</p>
	</td>
</tr>
<tr>
	<td>
		<ul>
		</ul>
	</td>
	<td>
		<p>Нарисовать наибольший равносторонний треугольник, который поместится в области вывода. Одна из сторон треугольника должна идти вдоль нижней границы области вывода. Боковые стороны необходимо нарисовать красными линиями, используя алгоритм Брезенхема. Основание нарисовать зеленой линией алгоритмом ЦДА. Размер псевдопикселя для всех отрезков составляет 20х20 пикселей.
		</p>
		<p>Дополнительное задание Добейтесь, чтобы размеры рисунка изменялись при изменении размеров области вывода (окна).
		</p>
		<p><br>
		</p>
	</td>
</tr>
<tr>
	<td>
		<ul>
		</ul>
	</td>
	<td>
		<p>Нарисовать красным цветом наибольшее изображение икосаэдра, которое поместится в области вывода ри-сунка. Ребра икосаэдра, наиболее близкие к наблюда-телю, (жирные линии) нарисовать, используя алгоритм
		</p>
		<p>несимметричный ЦДА и псевдопиксель размером 20х20 пикселей. Ребра дальние необходимо нарисо-вать, используя алгоритм Брезенхема и псевдопиксель размером 10х10 пикселей.
		</p>
		<p>Дополнительное задание: Добейтесь, чтобы размеры рисунка изменялись при изменении размеров области вывода (окна).
		</p>
		<p><br>
		</p>
	</td>
</tr>
<tr>
	<td>
		<ul>
		</ul>
	</td>
	<td>
		<p>На базе алгоритма ЦДА разработать алгоритм рисования пунктирной линии. Пунктирная линия состоит из отрезков, разделенных промежутка-ми. Длина отрезка не может быть больше 10 псев-допикселей. Длина промежутка составляет половину длины отрезка. Линия начинается и заканчивается от-резком. Все отрезки и промежутки должны иметь при-мерно одинаковую длину. Используя алгоритм Бре-зенхема и псевдопиксель 20х20, нарисовать зеленым цветом наибольший прямоугольник, который поме-стится в области вывода. Диагонали прямоугольника провести пунктирной линией красного цвета, исполь-зуя псевдопиксель 5х5.
		</p>
		<p>Дополнительное задание: Добейтесь, чтобы размеры рисунка изменялись при изменении размеров области вывода (окна).
		</p>
		<p><br>
		</p>
	</td>
</tr>
<tr>
	<td>
		<ul>
		</ul>
	</td>
	<td>
		<p>Нарисовать красным цветом наибольшее изображение куба, которое поместится в области вывода рисунка. Ребра куба наиболее близкие к наблюдателю (жирные линии) нарисовать, используя алгоритм Брезенхема и
		</p>
		<p>псевдопиксель размером 20х20 пикселей. Стороны дальние необходимо нарисовать, используя алгоритм несимметричный ЦДА и псевдопиксель размером 10х10 пикселей.
		</p>
		<p>Дополнительное задание: Добейтесь, чтобы размеры рисунка изменялись при изменении размеров области вывода (окна).
		</p>
		<p><br>
		</p>
	</td>
</tr>
<tr>
	<td>
		<ul>
		</ul>
	</td>
	<td>
		<p>Нарисовать зеленым цветом наибольшее изображение октаэдра, которое поместится в области вывода рисунка. Стороны октаэдра наиболее близкие к наблюдателю (жирные линии) нарисовать, используя алгоритм ЦДА и псевдопиксель размером 20х20 пикселей. Стороны дальние необходимо нарисовать, используя алгоритм Брезенхема и псевдопиксель размером 10х10 пикселей.
		</p>
		<p>Дополнительное задание: Добейтесь, чтобы размеры рисунка изменялись при изменении размеров области вывода (окна).
		</p>
		<p><br>
		</p>
	</td>
</tr>
</tbody>
</table>
<p><br>
</p>
  
  </div>
</body>
</html>
