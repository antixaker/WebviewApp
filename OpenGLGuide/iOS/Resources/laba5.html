<html>
<body>
<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="labstyles.css" type="text/css">
</head>
  <div id="main" bgcolor="#c0dbe4">
  
  <p><strong>Лабораторная работа №5</strong>
</p>
<p><strong>Тема</strong>: Геометрические преобразования на плоскости
</p>
<p><strong>Цель работы:</strong> Научиться выполнять геометрические преобразования над
</p>
<p>плоскими фигурами.
</p>
<p><strong>Теоретический материал.</strong>
</p>
<p>Матриці основних елементарних перетворень:
</p>
<ul>
	<li>матриця повороту(rotation) точки відносно початку координат у додатному напрямку: </li>
</ul>
<p><br>
</p>
<ul>
	<li>матриця розтягу(стиску) (dilation) відносно початку координат:</li>
</ul>
<p><br>
</p>
<ul>
	<li>матриця перенесення(translation) точки на вектор(m, n):</li>
</ul>
<p><br>
</p>
<ul>
	<li>матриця дзеркального відображення(reflection) відносно осі x:</li>
</ul>
<p><br>
</p>
<p>Перетворення системи координат задається матрицями:
</p>
<ul>
	<li><em>R(–</em><em>φ</em><em>)</em> – поворот системи координат на кут φ у додатному напрямі; </li>
	<li><em>T(–m, –n)</em> – зсув системи координат на вектор (<em>m, n</em>).</li>
</ul>
<p>Зауважимо, що для простоти запису аргументи наведених матриць іноді опускаються.
</p>
<p>Розглянемо декілька практичних прикладів.
</p>
<p><strong><em>Приклад 5.1</em></strong>. Побудувати матрицю повороту точкиM( x, y) відносно довільної точкиN(m, n) на кут φ у додатному напрямку (рис. 5.1).
</p>
<p><br>
</p>
<p>Рис. 5. 1 Поворот точки M у додатному напрямку відносно точки N
</p>
<p>Матриця R задає поворот точки відносно початку координат. Однорідні координати дають можливість знайти матрицю повороту відносно довільної точки. У загальному випадку поворот відносно довільної точки може бути реалізований шляхом таких перетворень:
</p>
<ul>
	<li>переміщення точки <em>N(m, n)</em> на вектор(–m, –n) так, щоб центр повороту сумістився з початком координат. Матриця цього перетворення</li>
</ul>
<p><br>
</p>
<ul>
	<li>повороту точки на кут φ у додатному напрямку відносно початку координат. Матриця цього перетворення R визначається формулою</li>
</ul>
<p><br>
</p>
<ul>
	<li>переміщення одержаного результату назад так, щоб центр повороту сумістився з точкою <em>N</em>. Матриця цього перетворення T визначається формулою</li>
</ul>
<p><br>
</p>
<p>Отже, для знаходження результуючого повороту точки <em>M(x, y)</em> відносно точки <em>N(m, n)</em> потрібно перемножити матриці T’, R, T за вказаним порядком.
</p>
<p>У результаті одержимо шукане перетворення у вигляді
</p>
<p><br>
</p>
<p>Зокрема, поворот точки на90<sup>0</sup> у додатному напрямку відносно точки <em>N(m, n) </em>виконується перетворенням
</p>
<p>.
</p>
<p><strong><em>Приклад 2</em></strong>. Побудувати матрицю неоднорідного масштабування з коефіцієнтом <em>a</em> вздовж осі <em>x</em> та коефіцієнтом <em>b</em> уздовж осі <em>y</em> з центром у точці <em>N(m, n)</em>.
</p>
<p>Це перетворення реалізуємо за допомогою трьох перетворень:
</p>
<ul>
	<li>переміщення точки на вектор <em>N(–m, –n)</em>. Матрицею цього перетворення є матриця <em>T’</em>.</li>
	<li>розтягу вздовж координатних осей із коефіцієнтами <em>a</em> та <em>b</em> відповідно. Матриця <em>D </em>цього перетворення визначається формулою</li>
</ul>
<p>;
</p>
<ul>
	<li>перенесення одержаного результату на вектор <em>N(m, n).</em> Матриця <em>T</em> цього перетворення має вигляд. </li>
</ul>
<p><br>
</p>
<p>Перемножуючи ці матриці, одержуємо шукане перетворення
</p>
<p><br>
</p>
<p>Аналогічно, виділяючи послідовність операцій перенесення, повороту та масштабування(ці перетворення описуються матрицями <em>T, R, D</em>), можна побудувати матрицю для будь-якого складного афінного перетворення. Тоді афінне перетворення об’єктів на площині можна здійснити так: якщо об’єкт задається сукупністю точок, то складаємо матрицю <em>X</em> однорідних координат точок цього об’єкта і цю матрицю множимо на матрицю складного афінного перетворення.
</p>
<p>Розглянемо приклад симетричного відображення трикутника відносно прямої <em>L</em>.
</p>
<p><strong><em>Приклад 3</em></strong>. Нехай пряма <em>L</em> задається рівнянням <em>y = x + 1</em>, а однорідні координати <em>A(1; 1; 1), B(6; 1; 1),C (6; 4; 1)</em> задають координати вершин трикутника <em>ABC</em>. Побудувати трикутник, симетричний даному відносно прямої <em>L</em>.
</p>
<p><br>
</p>
<p><br>
</p>
<p>Рис. 5. 2 Побудова симетричного трикутника
</p>
<p>Представимо перетворення симетрії точки відносно прямої у вигляді послідовності простіших афінних перетворень (рис. 5.2):
</p>
<ul>
	<li>переміщення лінії та трикутника так, щоб лінія <em>L</em> пройшла через початок координат. Це перетворення задає матриця <em>T</em> із параметрами(0, –1); </li>
	<li>поворот лінії та об’єкта відносно початку координат до збігу лінії <em>L</em> з віссю x. Це перетворення задає матриця R із кутом (у від’ємному напрямку); </li>
	<li>відображення відносно координатної осі x; </li>
	<li>обернений поворот відносно початку координат; </li>
	<li>паралельне перенесення у вихідне положення. </li>
</ul>
<p>Останні три перетворення задаються матрицями <em>Ref,</em> <em>R(-</em><em>φ</em>) та <em>T(0, 1)</em>, відповідно. У матричному вигляді перетворення симетрії має вигляд
</p>
<p><br>
</p>
<p>Для симетрії трикутника <em>ABC</em> відносно прямої <em>L</em> маємо
</p>
<p><br>
</p>
<p>Отже, декартові координати вершин симетричного трикутника <em>A′B′C′</em> мають значення A′(0; 2), B′(0; 7), C′(3; 7).
</p>
<p><strong>Задания.</strong>
</p>
<p><strong>Для решения задач можно использовать примитивы</strong>
</p>
<p><strong><em>1 уровень</em></strong>
</p>
<p>Данная работа содержит варианты разного уровня, поэтому прежде чем делать задание, выясните у Вашего преподавателя ваш вариант.
</p>
<p>Фигуру, подвергающуюся преобразованию, задайте массивом векторов, где каждый вектор представляет координаты одной из вершин фигуры.
</p>
<p>Необходимое преобразование задавайте матрицей3х3. Матрицу преобразования, являющегося комбинацией нескольких преобразований, формируйте путем последовательных перемножений матриц соответствующих преобразований.
</p>
<p>Следует программировать задачу в общем виде, используя параметры(угол поворота, величину перемещения, коэффициент масштабирования) и предполагая произвольную фигуру, но отлаживать программу на примере, указанном в задаче в скобках!
</p>
<p>На рисунках, приведенных в вариантах заданий, жирными линиями изображено первоначальное положение фигуры.
</p>
<p>Включив в программу необходимые задержки(используйте таймер), добейтесь желаемой скорости смены – изображений.
</p>
<table class="table table-responsive table-bordered table-hover">
<tbody>
<tr>
	<td>
		<p>Вариант
		</p>
	</td>
	<td>
		<p>Рисунок
		</p>
	</td>
</tr>
<tr>
	<td>
	</td>
	<td>
		<p>Поворачивать любую фигуру, образованную замкнутой ломаной линией (секундную стрелку), вокруг одной из ее вершин (оси вращения) на небольшой угол <em>r</em> по часовой стрелке (соответствующий секунде). Совершить <em>n</em> поворотов.
		</p>
		<p><br>
		</p>
		<p>Рис. 5. 3 Секундная стрелка
		</p>
		<p><strong><em>Дополнение:</em></strong> На основе полученной программы создайте часы - будильник, звонящие по достижении заданного времени. К рисунку добавьте часовую, минутную стрелки и стрелку будильника.
		</p>
	</td>
</tr>
<tr>
	<td>
	</td>
	<td>
		<p>Поворачивать любую фигуру, образованную отрезками прямых (велосипедное колесо ), и расположенную у левого края экрана, вокруг заданной точки фигуры (оси колеса), на угол <em>r</em> по часовой стрелке (на половину угла между соседними спицам), сдвигая, фигуру, по горизонтали вправо на величину <em>t</em>. Фигуру перемещать до правого края экрана. Один, из отрезков (спицу колеса) изобразить контрастным цветом. Величину <em>t</em> рассчитайте так, чтобы создавалось впечатление катящегося колеса, и проведите пунктирную горизонталь, через точки вращения.
		</p>
		<p><br>
		</p>
		<p>Рис. 5. 4 Колесо
		</p>
		<p><strong><em>Дополнение:</em></strong> Создайте картину движущегося по экрану велосипеда.
		</p>
	</td>
</tr>
<tr>
	<td>
	</td>
	<td>
		<p>Задана любая фигура двумя замкнутыми ломаными линиями (треугольник внутри квадрата). Требуется поворачивать фигуру вокруг заданной точки <em>z </em>(центра квадрата) на угол <em>r</em> (15 градусов) по часовой стрелке, незначительно уменьшая относительно точки и часть фигуры, образованную первой ломаной линией(треугольник), и во столько же раз увеличивая другую часть фигуры(квадрат). Преобразования повторять, пока уменьшающаяся часть не превратится в точку. Картина должна напоминать"вертушку", состоящую из удаляющегося при вращении треугольника и приближающегося квадрата. Затем повторить процесс, только уменьшать вторую часть фигуры и увеличивать первую. Повторять чередование, пока пользователь не завершит работу программы.
		</p>
		<p><br>
		</p>
		<p>Рис. 5. 5 Вертушка
		</p>
		<p><strong><em>Дополнение:</em></strong> Изменяйте скорость поворота маятника в соответствии с гармоническим закон колебаний. Создайте программу часов с маятником.
		</p>
	</td>
</tr>
<tr>
	<td>
	</td>
	<td>
		<p>Поворачивать любую фигуру, образованную отрезками прямых (маятник
		</p>
		<p>в крайнем левом положении, отклоненный, на 45 градусов от вертикали),
		</p>
		<p>вокруг точки в центре верхней половины экрана(оси маятника) на небольшой угол r (5 градусов) против часовой стрелки. Совершить k поворотов(достигнув крайнего правого положения). Затем, аналогично, выполнить k поворотов по часовой стрелке(до крайнего левого положения). Выполнить колебания фигуры, пока пользователь не завершит работу программы. Процесс должен напоминать колебание маятника
		</p>
		<p><br>
		</p>
		<p>Рис. 5. 6 Маятник
		</p>
	</td>
</tr>
<tr>
	<td>
	</td>
	<td>
		<p>Поворачивать любую фигуру, образованную отрезками прямых (лист
		</p>
		<p>дерева) и находящуюся в правой половине экрана, вокруг точки Р, лежащей в центре верхнего края экрана, на угол r (10 градусов) по часовой стрелке, каждый раз незначительно увеличивая фигуру относительно точки P. Повороты выполнять до тех пор, пока фигура не займет примерно симметричное первоначальному положение в левой половине экрана. Затем, аналогично, поворачивать фигуру против часовой стрелки вокруг той же точки P. Чередовать такие колебания фигуры, пока она остается в пределах экрана. Картина должна напоминать падение осеннего листа, сорвавшегося с дерева
		</p>
		<p><br>
		</p>
		<p>Рис. 5. 7 Падение листа
		</p>
		<p><strong><em>Дополнение:</em></strong> Создайте полную картину вращающегося колеса обозрения с шестью кабинами.
		</p>
	</td>
</tr>
<tr>
	<td>
	</td>
	<td>
		<p>Задана любая фигура, состоящая из отрезков(треугольник и прямоугольник с общей стороной, напоминающие кабину колеса обозрения); одна из точек фигуры особо выделена(точка подвески кабины). Поворачивать фигуру так, чтобы особая точка поворачивалась вокруг центра экрана на угол r (15 градусов) против часовой стрелки при каждом повороте. Совершать полные обороты фигуры вокруг центра экрана, пока пользователь не завершит работу программы. Картина должна напоминать вращение кабины колеса обозрения.
		</p>
		<p><br>
		</p>
		<p>Рис. 5. 8 Колесо обозрения
		</p>
		<p><strong><em>Дополнение:</em></strong> Создайте полную картину вращающегося колеса обозрения с шестью кабинами.
		</p>
	</td>
</tr>
<tr>
	<td>
	</td>
	<td>
		<p>Поворачивать любую фигуру, заданную замкнутой ломаной линией с яркой точкой на фигуре(многоугольник, похожий на круг, с ярким"пятном" на
		</p>
		<p>окружности), вокруг центра фигуры на угол r (30 градусов) по часовой стрелке, сдвигая фигуру так, чтобы она перемещалась по диагонали экрана, и
		</p>
		<p>незначительно увеличивая размеры фигуры в а раз (1.2 раза) относительно своего центра, но так, чтобы пятно, вращаясь вместе с фигурой, оставалось на прежнем расстоянии от ее центра. Картина должна напоминать катящийся с горы нарастающий снежный ком, а пятно напоминать о первоначальных размерах кома. Нарисовать гору и остановить ком в углу экрана.
		</p>
		<p><br>
		</p>
		<p>Рис. 5. 9 Снежный ком
		</p>
	</td>
</tr>
<tr>
	<td>
	</td>
	<td>
		<p>Задана любая фигура замкнутой ломаной линией(квадрат). Поворачивать фигуру вокруг своего центра на угол r (35 градусов) против часовой стрелки и одновременно вокруг центра экрана на угол s (20 градусов) по часовой стрелке. Одну из сторон фигуры выделить другим цветом. Совершать полные обороты фигуры вокруг центра экрана, пока пользователь не завершит работу программы. Картина должна напоминать карусель с вращающейся кабиной.
		</p>
		<p><br>
		</p>
		<p>Рис. 5. 10 Карусель с вращающейся кабиной
		</p>
		<p><strong><em>Дополнение:</em></strong> Создайте полную картину карусели с четырьмя вращающимися кабинами.
		</p>
	</td>
</tr>
<tr>
	<td>
	</td>
	<td>
		<p>Поворачивать любую фигуру, заданную замкнутой ломаной линией (вытянутый прямоугольник, стоящий у левого края экрана на наклонной линии), на угол r (90 градусов) по часовой стрелке вокруг первой вершины фигуры, затем на тот же угол вокруг второй вершины и т. д. k раз(каждый раз в качестве точки поворота выбирать нижний правый угол очередного прямоугольника, Одну из сторон фигуры(короткую) выделить другим цветом.
		</p>
		<p><br>
		</p>
		<p>Рис. 5. 11 Кувырок
		</p>
		<p><strong><em>Дополнение:</em></strong> Добейтесь того, чтобы прямоугольник стоял на выделенной стороне дольше, чем на остальных, и докувыркался до правого края экрана.
		</p>
	</td>
</tr>
</tbody>
</table>
<p><strong><em>2-уровень (максимальное количество баллов 80) выполнение всех пунктов задания.</em></strong>
</p>
<p>Создать систему декартовых координат с сеткой.
</p>
<p>В составе системы координат изобразить геометрическую фигуру, согласно варианту задания из таблицы 1. Фигура должна задаваться координатами вершин: A(x<sub>1</sub>,y<sub>1</sub>), B(x<sub>2</sub>,y<sub>2</sub>), C(x<sub>3</sub>,y<sub>3</sub>), и D(x<sub>4</sub>,y<sub>4</sub>) таким образом, чтобы она находилась в первом квадранте декартовой системы координат XOY, как показано на рисунке 6.1
</p>
<p>Задавая различные значения параметров видовых преобразований продемонстрировать следующие виды графических преобразований:
</p>
<p>1) Перенос фигуры из 1-го во 2-й, 3-й и 4-й квадранты;
</p>
<p>2) Сдвиг объекта вдоль каждой оси координат или вдоль обеих осей одновременно;
</p>
<p>3) Изменение масштаба объекта по оси X или по оси Y, а также изменение его размера по обеим осям одновременно;
</p>
<p>Преобразования типа "перенос" и "масштабирование" должны выполняться в режиме анимации. При этом необходимо принять меры к устранению эффекта «мерцания» изображения, возникающего в процессе этих преобразований.
</p>
<p><br>
</p>
<p><br>
</p>
<p>Рис. 5. 12 Система координат и исходная фигура
</p>
<p><br>
</p>
<p>Для решения задачи можно построить и затем воспользоваться формой
</p>
<p><br>
</p>
<p>Рис. 5. 13 Окно формы
</p>
<table class="table table-responsive table-bordered table-hover">
<tbody>
<tr>
	<td>
	</td>
	<td>
		<p><br>
		</p>
		<table class="table table-responsive table-bordered table-hover">
		<tbody>
		<tr>
			<td>
				<p>Тип фигуры
				</p>
			</td>
			<td>
				<p>Цвет фигуры
				</p>
			</td>
			<td>
				<p>Цвет осей
				</p>
			</td>
		</tr>
		<tr>
			<td>
				<p>квадрат
				</p>
			</td>
			<td>
				<p>красный
				</p>
			</td>
			<td>
				<p>черный
				</p>
			</td>
		</tr>
		</tbody>
		</table>
		<p><br>
		</p>
		<p><br>
		</p>
	</td>
</tr>
<tr>
	<td>
	</td>
	<td>
		<p><br>
		</p>
		<table class="table table-responsive table-bordered table-hover">
		<tbody>
		<tr>
			<td>
				<p>Тип фигуры
				</p>
			</td>
			<td>
				<p>Цвет фигуры
				</p>
			</td>
			<td>
				<p>Цвет осей
				</p>
			</td>
		</tr>
		<tr>
			<td>
				<p>прямоугольник
				</p>
			</td>
			<td>
				<p>синий
				</p>
			</td>
			<td>
				<p>голубой
				</p>
			</td>
		</tr>
		</tbody>
		</table>
		<p><br>
		</p>
		<p><br>
		</p>
	</td>
</tr>
<tr>
	<td>
	</td>
	<td>
		<p><br>
		</p>
		<table class="table table-responsive table-bordered table-hover">
		<tbody>
		<tr>
			<td>
				<p>Тип фигуры
				</p>
			</td>
			<td>
				<p>Цвет фигуры
				</p>
			</td>
			<td>
				<p>Цвет осей
				</p>
			</td>
		</tr>
		<tr>
			<td>
				<p>параллелограм
				</p>
			</td>
			<td>
				<p>зеленый
				</p>
			</td>
			<td>
				<p>коричневый
				</p>
			</td>
		</tr>
		</tbody>
		</table>
		<p><br>
		</p>
		<p><br>
		</p>
	</td>
</tr>
<tr>
	<td>
	</td>
	<td>
		<p><br>
		</p>
		<table class="table table-responsive table-bordered table-hover">
		<tbody>
		<tr>
			<td>
				<p>Тип фигуры
				</p>
			</td>
			<td>
				<p>Цвет фигуры
				</p>
			</td>
			<td>
				<p>Цвет осей
				</p>
			</td>
		</tr>
		<tr>
			<td>
				<p>ромб
				</p>
			</td>
			<td>
				<p>голубой
				</p>
			</td>
			<td>
				<p>синий
				</p>
			</td>
		</tr>
		</tbody>
		</table>
		<p><br>
		</p>
		<p><br>
		</p>
	</td>
</tr>
<tr>
	<td>
	</td>
	<td>
		<p><br>
		</p>
		<table class="table table-responsive table-bordered table-hover">
		<tbody>
		<tr>
			<td>
				<p>Тип фигуры
				</p>
			</td>
			<td>
				<p>Цвет фигуры
				</p>
			</td>
			<td>
				<p>Цвет осей
				</p>
			</td>
		</tr>
		<tr>
			<td>
				<p>треугольник
				</p>
			</td>
			<td>
				<p>красный
				</p>
			</td>
			<td>
				<p>черный
				</p>
			</td>
		</tr>
		</tbody>
		</table>
		<p><br>
		</p>
		<p><br>
		</p>
	</td>
</tr>
<tr>
	<td>
	</td>
	<td>
		<p><br>
		</p>
		<table class="table table-responsive table-bordered table-hover">
		<tbody>
		<tr>
			<td>
				<p>Тип фигуры
				</p>
			</td>
			<td>
				<p>Цвет фигуры
				</p>
			</td>
			<td>
				<p>Цвет осей
				</p>
			</td>
		</tr>
		<tr>
			<td>
				<p>квадрат
				</p>
			</td>
			<td>
				<p>красный
				</p>
			</td>
			<td>
				<p>коричневый
				</p>
			</td>
		</tr>
		</tbody>
		</table>
		<p><br>
		</p>
		<p><br>
		</p>
	</td>
</tr>
<tr>
	<td>
	</td>
	<td>
		<p><br>
		</p>
		<table class="table table-responsive table-bordered table-hover">
		<tbody>
		<tr>
			<td>
				<p>Тип фигуры
				</p>
			</td>
			<td>
				<p>Цвет фигуры
				</p>
			</td>
			<td>
				<p>Цвет осей
				</p>
			</td>
		</tr>
		<tr>
			<td>
				<p>прямоугольник
				</p>
			</td>
			<td>
				<p>синий
				</p>
			</td>
			<td>
				<p>голубой
				</p>
			</td>
		</tr>
		</tbody>
		</table>
		<p><br>
		</p>
		<p><br>
		</p>
	</td>
</tr>
<tr>
	<td>
	</td>
	<td>
		<p><br>
		</p>
		<table class="table table-responsive table-bordered table-hover">
		<tbody>
		<tr>
			<td>
				<p>Тип фигуры
				</p>
			</td>
			<td>
				<p>Цвет фигуры
				</p>
			</td>
			<td>
				<p>Цвет осей
				</p>
			</td>
		</tr>
		<tr>
			<td>
				<p>параллелограмм
				</p>
			</td>
			<td>
				<p>зеленый
				</p>
			</td>
			<td>
				<p>черный
				</p>
			</td>
		</tr>
		</tbody>
		</table>
		<p><br>
		</p>
		<p><br>
		</p>
	</td>
</tr>
<tr>
	<td>
	</td>
	<td>
		<p><br>
		</p>
		<table class="table table-responsive table-bordered table-hover">
		<tbody>
		<tr>
			<td>
				<p>Тип фигуры
				</p>
			</td>
			<td>
				<p>Цвет фигуры
				</p>
			</td>
			<td>
				<p>Цвет осей
				</p>
			</td>
		</tr>
		<tr>
			<td>
				<p>трапеция
				</p>
			</td>
			<td>
				<p>коричневый
				</p>
			</td>
			<td>
				<p>синий
				</p>
			</td>
		</tr>
		</tbody>
		</table>
		<p><br>
		</p>
		<p><br>
		</p>
	</td>
</tr>
<tr>
	<td>
	</td>
	<td>
		<p><br>
		</p>
		<table class="table table-responsive table-bordered table-hover">
		<tbody>
		<tr>
			<td>
				<p>Тип фигуры
				</p>
			</td>
			<td>
				<p>Цвет фигуры
				</p>
			</td>
			<td>
				<p>Цвет осей
				</p>
			</td>
		</tr>
		<tr>
			<td>
				<p>ромб
				</p>
			</td>
			<td>
				<p>голубой
				</p>
			</td>
			<td>
				<p>зеленый
				</p>
			</td>
		</tr>
		</tbody>
		</table>
		<p><br>
		</p>
		<p><br>
		</p>
	</td>
</tr>
<tr>
	<td>
	</td>
	<td>
		<p><br>
		</p>
		<table class="table table-responsive table-bordered table-hover">
		<tbody>
		<tr>
			<td>
				<p>Тип фигуры
				</p>
			</td>
			<td>
				<p>Цвет фигуры
				</p>
			</td>
			<td>
				<p>Цвет осей
				</p>
			</td>
		</tr>
		<tr>
			<td>
				<p>произвольный четырехугольник
				</p>
			</td>
			<td>
				<p>черный
				</p>
			</td>
			<td>
				<p>синий
				</p>
			</td>
		</tr>
		</tbody>
		</table>
		<p><br>
		</p>
		<p><br>
		</p>
	</td>
</tr>
<tr>
	<td>
	</td>
	<td>
		<p><br>
		</p>
		<table class="table table-responsive table-bordered table-hover">
		<tbody>
		<tr>
			<td>
				<p>Тип фигуры
				</p>
			</td>
			<td>
				<p>Цвет фигуры
				</p>
			</td>
			<td>
				<p>Цвет осей
				</p>
			</td>
		</tr>
		<tr>
			<td>
				<p>равносторонний треугольник
				</p>
			</td>
			<td>
				<p>зеленый
				</p>
			</td>
			<td>
				<p>синий
				</p>
			</td>
		</tr>
		</tbody>
		</table>
		<p><br>
		</p>
		<p><br>
		</p>
	</td>
</tr>
<tr>
	<td>
	</td>
	<td>
		<p><br>
		</p>
		<table class="table table-responsive table-bordered table-hover">
		<tbody>
		<tr>
			<td>
				<p>Тип фигуры
				</p>
			</td>
			<td>
				<p>Цвет фигуры
				</p>
			</td>
			<td>
				<p>Цвет осей
				</p>
			</td>
		</tr>
		<tr>
			<td>
				<p>Прямоугольный треугольник
				</p>
			</td>
			<td>
				<p>синий
				</p>
			</td>
			<td>
				<p>Зеленый
				</p>
			</td>
		</tr>
		</tbody>
		</table>
		<p><br>
		</p>
		<p><br>
		</p>
	</td>
</tr>
</tbody>
</table>
<p>Реализация задания второго уровня.
</p>
<ul>
	<li><strong><em></em></strong><strong><em>Установка панели Panel1 на форму</em></strong><strong><em>.</em></strong></li>
</ul>
<p>В окне <strong>ToolBox</strong> палитры компонентов выберите значок <strong>Panel</strong>, и установите панель на поле <strong>Form1</strong>, разверните панель, используя растягивание указателем мыши до требуемых размеров , панель должна быть вертикальной;
</p>
<p>Привяжите панель <strong>Panel1 </strong>к верхнему, правому и нижнему краю формы, для чего в окне <strong>Properties</strong> переустановите свойство <strong>Anchors</strong> панели в состояние <strong>[akTop, akRight, akBottom].</strong>
</p>
<p>В окне <strong>Properties</strong>, в строке <strong>Text</strong> удалите запись <strong>Panel1</strong>.
</p>
<ul>
	<li><strong><em></em></strong><strong><em>Установка панели Panel2 на форму.</em></strong></li>
</ul>
<p>Измените размеры <strong>Form3</strong> в высоту на величину высоты панели <strong>Panel2</strong> .
</p>
<p>Установите вторую панель <strong>Panel2 </strong> так, как показано на рисунке 5.13 способом, аналогичным п.1).
</p>
<p>Привяжите панель <strong>Panel2 </strong>к левому, правому и нижнему краю формы, для чего в окне <strong>Properties</strong> переустановите свойство <strong>Anchors</strong> панели в состояние <strong>[akLeft, akRight, akBottom].</strong>
</p>
<p>В окне <strong>Properties</strong>, в строке <strong>Text</strong> удалите запись <strong>Panel2</strong>.
</p>
<ul>
	<li><strong><em></em></strong><strong><em>Установка компонента TrackBar1 ("Масштабирование осей") на панель Panel1.</em></strong></li>
</ul>
<p>На вкладке <strong>AllWindowsForm</strong> выберите компонент <strong>TrackBar </strong> и установите его на поле панели <strong>Panel1</strong>.
</p>
<p>Для компонента <strong>TrackBar1</strong> в окне <strong>Properties</strong> выполните следующие настройки:
</p>
<p>- в строке<strong>Max</strong> (максимальное количество отсчетов) установите значение: 20;
</p>
<p>- в строке<strong>Min</strong> (минимальное количество отсчетов) установите значение: 5;
</p>
<p>- в строке<strong> Value</strong> (начальная позиция движка) установите значение: 10;
</p>
<p>- в строке<strong>TickStyle</strong> установите значение: <strong> tsManual</strong>;
</p>
<ul>
	<li><strong><em></em></strong><strong><em>Установка компонентов CheckBox на панель управления Panel1.</em></strong></li>
</ul>
<p>В группе A<strong>llWindowsForm</strong> выберите компонент <strong>CheckBox</strong> и установите его на поле панели <strong>Panel1</strong>.
</p>
<p>В окне <strong>Properties</strong>, в строке <strong>Text</strong> удалите запись <strong>CheckBox1</strong> и введите необходимый текста в соответсвтии с рисунком. Всего, согласно рисунку 5.13, надо установить три таких компонента с соответствующими подписями (сетка, обозначения, анимация).
</p>
<p>Введите надписи "<strong>Масштабирование осей</strong>", "<strong>Сетка</strong>", "<strong>Обозначения</strong>" и "<strong>Анимация</strong>" на поле панели <strong>Panel1 </strong>в соответствии с рисунком.
</p>
<ul>
	<li><strong><em></em></strong><strong><em>Установка кнопок "Запуск" и "Исходное" на панель управления.</em></strong></li>
</ul>
<p>В окне <strong>ToolBox</strong> щелкните по значку <strong>Button</strong>, а затем щелкните внутри области <strong>Panel1</strong> поля <strong>Form1</strong>, возникнет кнопка <strong>Button1</strong>, которую можно переместить в требуемое место панели и изменить её размеры.
</p>
<p>В окне <strong>Properties</strong>, в строке <strong>Caption</strong> вместо записи <strong>Button1</strong> введите: <strong>Пуск</strong>.
</p>
<p>Аналогично выполнить действия по созданию кнопки <strong>Исходное</strong>.
</p>
<ul>
	<li><strong><em></em></strong><strong><em>Установка компонентов DataGridView1 на панель управления Panel2.</em></strong></li>
</ul>
<p>В окне <strong>ToolBox</strong> выберите компонент <strong>DataGridView</strong> и установите его на поле панели <strong>Panel2</strong>.
</p>
<p>Для компонента <strong>DataGridView1</strong> в окне <strong>Properties</strong> выполните следующие настройки:
</p>
<p>- в строке <strong>RowHeadersVisible</strong> (отображение заголовков строк) установите значение <strong>False</strong>;
</p>
<p>- в строке <strong>ColumnHeadersVisible</strong> (отображение заголовков столбцов) установите значение <strong>False</strong>;
</p>
<p>- в строке <strong>ScrollBars</strong> (отображение полос прокрутки) установите значение <strong>None (нет)</strong>;
</p>
<p>- в метод <strong>InitializeComponent() </strong>в области, связанной с <strong>DataGridView1 </strong>введите следующую команду
</p>
<p>this-&gt;dataGridView1-&gt;ColumnCount=3;(определяем количество столбцов в массиве 3)
</p>
<p>- в строке <strong>AvtoSizeColumnMode</strong> (занимать пространство компонента) установите значение <strong>Fill</strong>;
</p>
<p>- в строке <strong>GridColor</strong> (цвет сетки) установите значение <strong>ActiveCaptionText</strong> (черный);
</p>
<p>- в строке <strong>AllowUserToAddRows </strong> (фиксируем количество строк) установите значение <strong>false</strong>.
</p>
<p>Щелкните по компоненту <strong>DataGridView1</strong>правой кнопкой мыши и в открывшемся меню выберите <strong>Copy</strong>. Щелкните правой кнопкой на поле панели <strong>Panel2</strong> и в меню выберите <strong>Paste</strong>. На панели будет создана копия компонента - <strong>DataGridView2</strong>. Аналогичным образом создайте третий компонент - <strong>DataGridView3.</strong> Разместите все три компонента <strong>DataGridView</strong> на панели <strong>Panel2</strong> согласно рисунку 5.12.
</p>
<p>Для компонента <strong>DataGridView2</strong> исправьте свойство <strong>RowCount </strong> на значение: 3, т.е явно пропишите this-&gt;dataGridView2-&gt;RowCount=3;
</p>
<p>Для компонента <strong>DataGridView3</strong> явно пропишите this-&gt;dataGridView3-&gt;RowCount=4.
</p>
<ul>
	<li><strong><em></em></strong><strong><em>Установка компонентов Label на панель управления Panel2:</em></strong></li>
</ul>
<p>Используя компоненты Label и их свойство text, введите математические символы "<strong>Х</strong>" и "<strong>=</strong>" на поле панели <strong>Panel2 </strong>в соответствии с рисунком 5.12.
</p>
<p>Установите названия матриц для компонентов <strong>DataGridView </strong> на панели <strong>Panel2</strong> согласно рисунку 5.12.
</p>
<p>По требованию задачи проект должен выполнять следующие действия:
</p>
<p>- создание осей координат – <strong>ShowOsi()</strong>;
</p>
<p>- изображение сетки на поле графического окна – <strong>ShowStk()</strong>;
</p>
<p>- вывод матриц исходных и результирующих координат и матрицы преобразования;
</p>
<p>- масштабирование осей координат и изображения в них;
</p>
<p>- видовые преобразования исходной фигуры – <strong>Preobr()</strong>;
</p>
<p>- нормировка координат преобразованной фигуры – <strong>Normir()</strong>;
</p>
<p>- прорисовка исходной и преобразованной фигуры –
</p>
<p><strong>ShowFig(TColor col, float matrT[4][3])</strong>;
</p>
<p>- прорисовка обозначений вершин фигуры – <strong>Oboznath(float matrTo[4][3])</strong>;
</p>
<p>- установка фигуры в исходное положение.
</p>
<p>Запуск всех функций прорисовки объединим под одной общей функцией - <strong>ShowAll()</strong>, а запуск всех функций преобразования и прорисовки изображения объединим под функцией - <strong>GrafKonv()</strong>, которая будет выполнять роль графического конвейера.
</p>
<p>Для таких действий как вывод матриц исходных и результирующих координат, масштабирование осей координат и установка фигуры в исходное положение отдельные функции создавать не будем, для их реализации достаточно использовать стандартные обработчики <strong>DataGridView</strong>, <strong>TrackBar1</strong> и <strong>Button2</strong>.
</p>
<p>Запуск функции <strong>GrafKonv()</strong>, будем осуществлять из обработчика <strong>FormPaint()</strong>, который должен вызываться при каждом обращении пользователя к элементам управления (кнопкам. движкам, флажкам и т.п.). Порядок программирования этих обработчиков будет рассмотрен ниже.
</p>
<p>Объектами обработки для функций <strong>Preobr()</strong>, <strong>Normir()</strong>, <strong>ShowFig()</strong> и <strong>Oboznath()</strong> являются координаты фигуры <strong>ABCD</strong>, сгруппированные в матрицы. Координаты находятся на различных стадиях обработки, и поэтому они должны быть помещены в отдельные матрицы с различными именами, соответствующими этим стадиям, а именно:
</p>
<p>matrIsx[4][3] - матрица исходных координат;
</p>
<p>matrIzm[4][3] - матрица преобразованных (измененных) координат;
</p>
<p>matrRez[4][3] - матрица ортонормированных координат;
</p>
<p>matrEkr[4][2] - матрица экранных координат.
</p>
<p>Матрицу исходных координат мы создаем для того, чтобы обеспечить первоначальную прорисовку фигуры, сразу после запуска проекта или после нажатия на кнопку <strong>"Исходное"</strong>.
</p>
<p>Матрица измененных координат получается после преобразования исходных координат фигуры с помощью матрицы видового преобразования <strong>Tpr[3][3]</strong>.
</p>
<p>Матрицу результирующих координат мы получим после нормировки преобразованных координат.
</p>
<p>Матрицу экранных координат получим после пересчета ортонормированных координат в экранные.
</p>
<p>Кроме этого, для преобразования координат фигуры необходима матрица видового преобразования - <strong>Tpr[3][3]</strong>.
</p>
<p>Поэтому, с учетом вышесказанного, в начальной части файла реализации объявим глобально все матрицы координат фигуры, матрицу преобразования фигуры и прототипы всех используемых функций преобразования и прорисовки изображения, а также все наиболее употребимые переменные в следующем виде:
</p>
<p>Graphics::TBitmap * formBitmap; // Описание указателя на буфер
</p>
<p>static int W, H, nOs, h, hh, i, j, k;
</p>
<p>static float a, b, d, e, l, m, p, q, s;
</p>
<p>static float matrIsx[4][3];
</p>
<p>static float matrIzm[4][3];
</p>
<p>static float matrRez[4][3];
</p>
<p>int matrEkr[4][2];
</p>
<p><br>
</p>
<p>static float Tpr[3][3];
</p>
<p><br>
</p>
<p>static void GrafKonv(void);
</p>
<p>static void Preobr(void);
</p>
<p>static void Normir(void);
</p>
<p><br>
</p>
<p>static void ShowAll(void);
</p>
<p>static void ShowOsi(void);
</p>
<p>static void ShowStk(void);
</p>
<p>static void ShowFig(TColor col, float matrT[4][3]);
</p>
<p>static void Oboznath(float matrTo[4][3]);
</p>
<p>Здесь, как видим, объявлен также ссылка на графический буфер класса <strong>TBitmap</strong>.
</p>
<p>Графический буфер – это битовая матрица, служащая для хранения в ней изображения (картинки) в формате <strong>.bmp</strong>, т.е. в пикселях.
</p>
<p>Необходимость создания буфера в этой лабораторной работе определяется тем обстоятельством, что видовые преобразования фигуры должны выполняться в режиме анимации, осуществление которой потребует многократной перерисовки изображения. Если не применять отрисовку с буферизацией, то качество изображения будет очень низким из-за появления черных полос в области графического окна проекта.
</p>
<p>Порядок использования графического буфера следующий:
</p>
<p>- сначала забелим поверхность битмапа, т.е. графического буфера;
</p>
<p>- после этого на его поле можно выполнять прорисовки с использованием команды:
</p>
<p>formBitmap-&gt;Canvas-&gt; &lt;имя функции прорисовки&gt;;
</p>
<p>- затем содержимое буфера копируется в графическое окно формы с помощью команды:
</p>
<p>Form3-&gt;Canvas-&gt;Draw(0, 0, formBitmap);
</p>
<p>Здесь, параметр <strong>formBitmap</strong> - это имя буфера, его можно выбирать любым. Практический пример использования буфера рассмотрим далее, при описании функции <strong>FormPaint()</strong>.
</p>
<p><strong>Разработка функции инициализации исходных данных Form1_Load()</strong>
</p>
<p><strong>FormCreate()</strong>
</p>
<p>Обработчик события <strong>Form1_Load() </strong>позволяет выполнять операцию предварительной инициализации данных сразу при запуске программы. Для его создания надо открыть вкладку <strong>Events</strong> окна <strong>Properties</strong> для формы <strong>Form1 </strong>и щелкнуть по строке<strong> Load</strong>, затем дважды щелкнуть по открывшемуся белому окошку. В окне редактора кода появится заголовок новой функции:
</p>
<p><strong>private: System::Void Form1_Load(System::Object^ sender, System::EventArgs^ e) {}</strong>
</p>
<p>void __fastcall TForm1::FormCreate(TObject *Sender){}
</p>
<p>Внутри фигурных скобок этой функции впишем команды обеспечивающие следующее:
</p>
<p>- инициализацию графического буфера;
</p>
<p>- инициализацию матрицы исходных координат <strong>matrIsx[4][3]</strong>;
</p>
<p>- инициализацию матрицы видового преобразования <strong>Tpr[3][3]</strong>;
</p>
<p>- инициализацию переменной <strong>nOs</strong>.
</p>
<p><br>
</p>
<p>Для инициализации графического буфера впишем следующие команды:
</p>
<p><br>
</p>
<p>W=this-&gt;Width - groupBox1-&gt;Width -10; // Задаем ширину графич. окна на форме
</p>
<p>H=this-&gt;Height - groupBox2-&gt;Height-10; // Задаем высоту графич. окна на форме
</p>
<p>formBitmap=new Graphics::TBitmap(); // Выделям динамич. память под буфер
</p>
<p>formBitmap-&gt;Width = W; // Задаем ширину битмапа
</p>
<p>formBitmap-&gt;Height= H; // Задаем высоту битмапа
</p>
<p>formBitmap-&gt;Canvas-&gt;Brush-&gt;Color=clWhite; // Задаем цвет закраски битмапа
</p>
<p>Инициализацию матрицы исходных координат выполним следующим образом:
</p>
<p>matrIsx[0][0]=1; matrIsx[0][1]=1; matrIsx[0][2]=1;
</p>
<p>matrIsx[1][0]=2; matrIsx[1][1]=3; matrIsx[1][2]=1;
</p>
<p>matrIsx[2][0]=4; matrIsx[2][1]=3; matrIsx[2][2]=1;
</p>
<p>matrIsx[3][0]=5; matrIsx[3][1]=2; matrIsx[3][2]=1;
</p>
<p>Понятно, что каждый студент здесь должен вписать другие численные значения. Координаты вершин фигуры можно выбирать любые, но так, чтобы форма фигуры соответствовала заданному варианту.
</p>
<p>Далее, инициализируем матрицу видового преобразования. В начальный период она имеет вид единичной матрицы, так как ни один из её параметров еще не "включен":
</p>
<p>Tpr[0][0]=1; Tpr[0][1]=0; Tpr[0][2]=0;
</p>
<p>Tpr[1][0]=0; Tpr[1][1]=1; Tpr[1][2]=0;
</p>
<p>Tpr[2][0]=0; Tpr[2][1]=0; Tpr[2][2]=1;
</p>
<p>Затем выводим значения элементов матриц <strong>matrIsx[4][3]</strong> и <strong>Tpr[3][3]</strong> в соответствующие окна вывода <strong>DataGridView1 </strong>и <strong>DataGridView2</strong>. Пример заполнения первых двух строк для каждого из этих окон имеет вид:
</p>
<p>for(int j=0; j&lt;dataGridView1-&gt;RowCount;j++)
</p>
<p>for (int i=0;i&lt;dataGridView1-&gt;ColumnCount;i++)
</p>
<p>dataGridView1-&gt;Rows[j]-&gt;Cells[i]-&gt;Value=matrIsx[j][i].ToString();
</p>
<p>for(int j=0; j&lt;dataGridView2-&gt;RowCount;j++)
</p>
<p>for (int i=0;i&lt;dataGridView2-&gt;ColumnCount;i++)
</p>
<p>dataGridView2-&gt;Rows[j]-&gt;Cells[i]-&gt;Value=Tpr[j][i].ToString();
</p>
<p>В заключение зададим количество отсчетов на осях <strong>X</strong> и <strong>Y</strong> с помощью переменной: <strong>nOs</strong> = 10.
</p>
<p><strong>7.4. Создание обработчика события FormPaint</strong>
</p>
<p>В отличие от лабораторной работы №1, где мы выполняли прорисовку изображения на поле объекта <strong>PaintBox1,</strong> в этой лабораторной работе предлагается выполнить прорисовку прямо на поле самой формы <strong>Form3, </strong> используя свойство <strong>Canvas</strong>, которым обладает любая форма. Для этого откройте вкладку <strong>Events</strong> окна <strong>Object Inspector </strong>и щелкните по строке<strong>OnPaint</strong>. Для создания обработчика события <strong>FormPaint</strong> дважды щелкните по открывшемуся белому окошку.
</p>
<p>Перейдите в окно <strong>Unit3.cpp</strong> с текстом программы. В нем появилась новая функция <strong>FormPaint,</strong> внутри фигурных скобок которой надо вписать команды обработки графического буфера. После чего текст программного кода функции будет иметь следующий вид:
</p>
<p>void __fastcall TForm3::FormPaint(TObject *Sender)
</p>
<p>{
</p>
<p> formBitmap-&gt;Canvas-&gt;FillRect(Rect(0, 0, W, H)); // Забеливаем битмап
</p>
<p> GrafKonv(); // Вызываем конвейер (рисуем на битмапе)
</p>
<p> Canvas-&gt;Draw(0, 0, formBitmap); // Перерисовываем битмап на форму
</p>
<p>}
</p>
<p>Из текста комментариев к командам понятны действия, выполняемые данным обработчиком.
</p>
<p>Первая команда подготавливает поле графического буфера для рисования.
</p>
<p>Вторая команда выполняет все необходимые прорисовки на битмапе (см. п. 7.5).
</p>
<p>Третья команда копирует изображение битмапа в ту область формы, которая задана параметрами канвы.
</p>
<p>Закомментируйте на период отладки вызов функции <strong>GrafKonv()</strong> и запустите проект на исполнение. Убедитесь, что в окне проекта формы <strong>Form3,</strong> в его левой части, появился белый прямоугольник графического окна.
</p>
<p><strong>7.5. Разработка функции графического конвейера GrafKonv()</strong>
</p>
<p>В задачу функции <strong>GrafKonv()</strong> входит последовательный запуск функций, ответственных за видовые преобразования фигуры, нормировку преобразованных координат фигуры и полную прорисовку всего изображения. Текст функции будет иметь вид:
</p>
<p>void GrafKonv(void)
</p>
<p>{
</p>
<p> Preobr(); // Вызываем функцию преобразования фигуры
</p>
<p> Normir(); // Вызываем функцию нормировки преобразованных координат
</p>
<p> ShowAll(); // Рисуем на битмапе всё: сетку, оси, фигуру, обозначения
</p>
<p>}
</p>
<p>Если запустить на этом этапе программу, то компилятор выведет сообщение об ошибке, т.к. ни одна из функций, вызываемых здесь, еще не существует, их описание будем разрабатывать далее. А пока, чтобы можно было продолжать формирование текста программы и выполнять отладку её функций, надо закомментировать, т.е. заглушить вызовы не созданных функций <strong>Preobr()</strong>,<strong>Normir()</strong> и <strong>ShowAll()</strong>. Затем раскомментируйте вызов <strong>GrafKonv()</strong> в обработчике <strong>FormPaint</strong> и запустите программу на исполнение. После добавления в текст программы описания каждой из вызываемых функций, заглушки можно будет последовательно снимать.
</p>
<p><strong>7.6. Видовые преобразования координат фигуры. Разработка функции Preobr()</strong>
</p>
<p>Для изменения местоположения, формы или размеров фигуры к ней необходимо применить видовые преобразования. Для преобразования матрицы координат фигуры с помощью матрицы видового преобразования создадим функцию <strong>Preobr()</strong>. В её работу будет входить выполнение операции перемножения двух матриц: матрицы исходных координат <strong>matrIsx[4][3]</strong> и матрицы видового преобразования <strong>Tpr[3][3]</strong>. В результате этой операции мы получим преобразованную матрицу <strong>matrIzm[4][3]</strong> (в соответствии с выражением (1), представленным в разделе "Краткие теоретические сведения"). Эту матрицу затем необходимо отнормировать с помощью функции <strong>Normir()</strong>. Запуск функции преобразования <strong>Preobr(),</strong> а также функции нормировки фигуры осуществляется после нажатия на кнопку "<strong>Запуск</strong>". При этом вызывается процесс перерисовки графического окна и соответственно запуск графического конвейера <strong>GrafKonv()</strong>, в составе которого и находятся функции <strong>Preobr()</strong> и <strong>Normir()</strong>.
</p>
<p>Текст программного кода функции <strong>Preobr()</strong> имеет следующий вид:
</p>
<p>void Preobr(void)
</p>
<p>{
</p>
<p> for(i=0; i&lt;4; i++)
</p>
<p> {for(j=0; j&lt;3; j++)
</p>
<p> {float Sum=0;
</p>
<p> for(k=0; k&lt;3; k++)
</p>
<p> Sum=Sum+matrIsx[i][k]* Tpr[k][j];
</p>
<p> matrIzm[i][j]=Sum;
</p>
<p> }
</p>
<p> }
</p>
<p>}
</p>
<p>Здесь как видим выполняется поэлементное перемножение двух матриц в соответствии с правилами перемножения матриц.
</p>
<p>Раскомментируйте вызов функции <strong>Preobr()</strong>, находящийся в <strong>GrafKonv()</strong> и запустите проект на исполнение для обнаружения ошибок в программном коде.
</p>
<p><strong>7.7. Нормировка координат фигуры</strong>
</p>
<p>Нормировку преобразованных координат фигуры, записанных в матрице <strong>matrIzm[4][3]</strong> необходимо выполнять для перевода этих координат из однородной системы координат в декартовую. Принцип нормировки координат результирующей матрицы определяется математическим выражением (5), представленным в разделе "Краткие теоретические сведения", данной лабораторной работы.
</p>
<p>Создадим функцию <strong>Normir()</strong>, внутри которой организуем два вложенных цикла, необходимых для обработки матрицы координат фигуры и с их помощью выполним поэлементное деление параметров матрицы на последний элемент текущей строки, если он не равен единице. Кроме этого, надо проверить, не равен ли этот последний элемент нулю, потому что, понятно, на нуль делить нельзя. Если все-таки это случилось, то этому нулевому элементу надо присвоить какое-либо очень маленькое значение.
</p>
<p>void Normir(void)
</p>
<p>{
</p>
<p> for(int i=0; i&lt;4; i++)
</p>
<p> for(int j=0; j&lt;3; j++)
</p>
<p> {if(matrIzm[i][2]!=1)
</p>
<p> {if(matrIzm[i][2]==0)
</p>
<p> matrIzm[i][2]=0,001;
</p>
<p> matrRez[i][j]=matrIzm[i][j]/matrIzm[i][2];
</p>
<p> }
</p>
<p> else matrRez[i][j]=matrIzm[i][j];
</p>
<p> }
</p>
<p>}
</p>
<p>Отнормированные координаты преобразованной фигуры <strong>matrRez[4][3]</strong> можно теперь использовать в функциях <strong>ShowFig()</strong> и <strong>Oboznath()</strong> для прорисовки фигуры и простановки обозначений возле её вершин.
</p>
<p>Раскомментируйте вызов функции <strong>Normir()</strong>, находящийся в <strong>GrafKonv()</strong> и запустите проект на исполнение для проверки.
</p>
<p><strong>7.8. Разработка функции прорисовки изображения ShowAll()</strong>
</p>
<p>В задачу функции <strong>ShowAll()</strong> входит последовательный запуск функций, ответственных за прорисовку конкретных элементов изображения: осей координат, сетки, фигуры и обозначения вершин фигуры. В обязанность этой функции также входит проверка состояния флажков "<strong>Сетка</strong>" и "<strong>Обозначения</strong>", установленных на панели <strong>Panel1</strong>.
</p>
<p> Порядок вызова функций прорисовки, входящих в состав <strong>ShowAll()</strong>, определяется тем, что каждое последующее изображение накладывается на предыдущее. Поэтому, чтобы не происходила зарисовка важной информации нужно определить, какое изображение является основным, а какое – второстепенным или фоновым. В нашем проекте основным является преобразованное изображение фигуры, а исходная фигура, оси координат, сетка, обозначения вершин – второстепенными. Поэтому, сначала надо вызывать второстепенные функции в порядке их нарастающей значимости, а затем основную. Тогда текст функции <strong>ShowAll()</strong> будет иметь вид:
</p>
<p>void ShowAll(void)
</p>
<p>{
</p>
<p> if(Form3-&gt;CheckBox1-&gt;Checked) // Если флажок "Сетка" включен,
</p>
<p> ShowStk(); // рисуем сетку
</p>
<p> ShowOsi(); // Рисуем оси
</p>
<p> ShowFig(clSilver, matrIsx); // Рисуем исходную фигуру
</p>
<p> if(Form3-&gt;CheckBox2-&gt;Checked) // Если флажок "Обозначения"включен,
</p>
<p> Oboznath(matrIsx); // проставляем исходные обозначения
</p>
<p> ShowFig(clRed, matrRez); // Рисуем преобразованную фигуру
</p>
<p> if(Form3-&gt;CheckBox2-&gt;Checked) // Если флажок "Обозначения" включен,
</p>
<p> Oboznath(matrRez); // проставляем преобразованные обозначения
</p>
<p>}
</p>
<p>Как видно из текста программы, функции прорисовки фигуры и обозначений вершин вызываем дважды: первый раз рисуется исходная фигура серым цветом, второй раз рисуется преобразованная фигура красным цветом.
</p>
<p>Пока не созданы описания функций <strong>ShowStk()</strong>, <strong>ShowOsi(),</strong> <strong>ShowFig()</strong> и <strong>Oboznath()</strong> закомментируйте их вызовы в <strong>ShowAll()</strong>. Затем раскомментируйте вызов <strong>ShowAll()</strong> в функции <strong>GrafKonv()</strong> и запустите проект на исполнение для проверки.
</p>
<p><strong>7.9. Разработка функции построения осей координат ShowOsi()</strong>
</p>
<p>Процесс создания функции <strong>ShowOsi()</strong> следующий:
</p>
<p>а) В программный код файла реализации <strong>Unit3.cpp</strong> впишите заголовок этой функции. Его текст соответствует тексту объявленного прототипа этой функции. Далее, внутри фигурных скобок этой функции вписываются команды, обеспечивающие рисование на битмапе.
</p>
<p>б) Задаем стиль и цвет линий, которыми будут прорисовываться оси:
</p>
<p>FBC-&gt;Pen-&gt;Style=psSolid; // Устанавливаем свойства пера
</p>
<p>FBC-&gt;Pen-&gt;Color=clBlack;
</p>
<p>Здесь - <strong>FBC </strong> это идентификатор макроса для выражения <strong>formBitmap-&gt;Canvas</strong>, который мы введем в целях уменьшения длины этой цепочки в командах прорисовки изображения и настройки параметров рисования. Поэтому, в область объявления макросов необходимо ввести следующую запись:
</p>
<p>#define FBC formBitmap-&gt;Canvas
</p>
<p>в) Проведем горизонтальную ось <strong>X</strong> с помощью команд:
</p>
<p>FBC-&gt;MoveTo(0, H/2); // Рисуем ось Х
</p>
<p>FBC-&gt;LineTo(W, H/2);
</p>
<p>Уберите заглушку, установленную перед вызовом <strong>ShowOsi()</strong> в функции <strong>ShowAll()</strong> и запустите проект на исполнение для проверки правильности прорисовки горизонтальной оси.
</p>
<p>г) Проведем вертикальную ось <strong>Y</strong> с помощью этих же команд с координатами, соответствующими положению оси (выполнить самостоятельно). Запустите проект на исполнение для проверки.
</p>
<p>д) Формируем стрелки на концах осей, используя команды <strong>MoveTo</strong> и <strong>LineTo </strong>(самостоятельно).
</p>
<p>е) Устанавливаем буквы ‘<strong>X</strong>’ и ‘<strong>Y</strong>’ возле осей:
</p>
<p>FBC-&gt;TextOut(x1, y1, 'X');
</p>
<p>FBC-&gt;TextOut(x2, y2, 'Y');
</p>
<p>Здесь <strong>x1, y1, x2, y2</strong> – координаты расположения символов <strong>‘X’</strong> и <strong>‘Y’</strong>.
</p>
<p>Реальные значения <strong>x1, y1, x2, y2</strong> надо задать заранее, перед вызовом команд TextOut() (самостоятельно). Переменные <strong>x1, y1, x2,y2</strong> объявите локально (внутри данной функции) как <strong>int</strong>.
</p>
<p>ж) Прорисовываем отсчеты на осях <strong>X</strong> и <strong>Y </strong> в виде коротких отрезков (количество отсчетов на каждой полуоси равно <strong>nOs</strong>), с использованием цикла <strong>for</strong>. Внутри этого же цикла вводим команду, выполняющую простановку соответствующих цифр (от 1 до значения <strong>nOs</strong>) возле каждого отсчета на полуоси. Пример простановки отсчетов и обозначений на положительной полуоси <strong>OХ</strong>имеет следующий вид:
</p>
<p>h=W/(2*(nOs+1));
</p>
<p>hh=h;
</p>
<p>for (int i=1; i&lt;nOs+1; i++)
</p>
<p> { FBC-&gt;MoveTo((W/2+hh), (H/2-3)); //Отсчеты на полуоси +Х
</p>
<p> FBC-&gt;LineTo((W/2+hh), (H/2+3));
</p>
<p> // Здесь самостоятельно вписываем команды для остальных полуосей
</p>
<p> FBC-&gt;TextOut((W/2+hh), (H/2+10), i); //Оцифровка полуоси +Х
</p>
<p> // Здесь самостоятельно вписываем команды для остальных оцифровок
</p>
<p> hh=h*(i+1);
</p>
<p> } // цикл завершен
</p>
<p>Здесь переменная <strong>h </strong>– цена делений (отсчетов), на которые разбиваются оси<strong> X </strong>и<strong> Y. </strong>Она зависит от ширины окна и от количества отсчетов на осях, задаваемых переменной масштабирования осей<strong> nOs.</strong> <br> Переменная <strong>hh</strong> – отстояние конкретного отсчета от центра системы координат.
</p>
<p>Переменная <strong>nOs</strong> – это количество отсчетов на любой из полуосей. Начальное значение этой переменной задано в функции <strong>FormCreate()</strong> в виде: <strong>nOs</strong> =10. В дальнейшем её значение можно изменять с помощью компонента <strong>TrackBar1</strong>.
</p>
<p>Запустите программу на исполнение и убедитесь в правильности прорисовки осей.
</p>
<p><strong>7.10. Разработка функции построения сетки ShowStk()</strong>
</p>
<p>В программный код файла реализации <strong>Unit3.cpp</strong> впишем заголовок этой функции:
</p>
<p>void ShowStk(void)
</p>
<p>Затем, внутри фигурных скобок этой функции необходимо вписать команды рисования пунктирных горизонтальных и вертикальных линий. Процесс построения сетки аналогичен прорисовке отсчетов на осях в функции <strong>ShowOsi()</strong>. Здесь также необходимо использовать оператор цикла для прорисовки параллельных пунктирных линий, совпадающих с отсчетами на осях. Только длина этих линий будет равна не длине отсчетов, а длине каждой из осей координат соответственно.
</p>
<p>Перед началом прорисовки необходимо установить стиль линий - пунктирный и цвет линий – серый:
</p>
<p>FBC-&gt;Pen-&gt;Style=psDot; // Устанавливаем стиль линий для сетки - пунктир
</p>
<p>FBC-&gt;Pen-&gt;Color=clSilver; // Задаем цвет линий сетки – серый
</p>
<p> // Здесь самостоятельно вписываем команды прорисовки горизонтальных и
</p>
<p> // вертикальных линий сетки в цикле
</p>
<p> После окончания прорисовки сетки свойства пера необходимо вернуть в исходное состояние (см. п. 7.9).
</p>
<p>Как видно из текста программного кода функции <strong>ShowAll(), </strong> прорисовка сетки осуществляется только в том случае, если включен флажок компонента <strong>CheckBox1.</strong>
</p>
<p>Для того, чтобы при переключении состояния флажка выполнялась прорисовка сетки, или наоборот не выполнялась, необходимо создать обработчик события <strong>CheckBox1Click</strong>, с помощью которого можно вызывать команду <strong>FormPaint(0)</strong> для перерисовки графического окна. При этом будет производиться вызов конвейера, с входящими в него командами проверки включения флажка и последующей прорисовки сетки. Порядок создания этого обработчика приведен в разделе 7.16.
</p>
<p>Не забудьте убрать заглушку на вызове <strong>ShowStk()</strong> в функции <strong>ShowAll()</strong>.
</p>
<p>После этого можно запустить программу на исполнение и убедиться в том, что сетка прорисовывается при включении флажка компонента “<strong>Сетка</strong>”, и наоборот, исчезает при его выключении.
</p>
<p><strong>7.11. Масштабирование осей координат</strong>
</p>
<p>Принцип масштабирования осей координат и объектов, расположенных в графическом окне формы основан на изменении значения переменной <strong>nOs</strong>, которая отвечает за количество отсчетов на координатной полуоси. Эта переменная в свою очередь влияет на цену деления <strong>h</strong> для осей <strong>X</strong> и <strong>Y,</strong> а следовательно и на конкретные размеры осей и объектов. Изменение значения переменной <strong>nOs</strong> в программе осуществляется с помощью компонента <strong>TrackBar</strong>. Для его использования создадим функцию обработки события на перемещение движка <strong>TrackBar1</strong>, для чего необходимо дважды щелкнуть по этому компоненту на поле конструктора формы <strong>Form3</strong>. В окне редактора кода <strong>Unit3.cpp</strong> появится заголовок новой функции, внутри фигурных скобок которой впишем:
</p>
<p>void __fastcall TForm3::TrackBar1Change(TObject *Sender)
</p>
<p>{
</p>
<p> nOs=Form3-&gt;TrackBar1-&gt;Position; // Читаем переметры TrackBar1
</p>
<p> FormPaint(0); // Запускаем перерисовку графич. окна
</p>
<p>}
</p>
<p>Здесь, как видно из текста функции, осуществляется присвоение переменной <strong>nOs</strong> значения позиции движка - <strong>Position</strong>. Затем вызывается команда <strong>FormPaint(0)</strong> для перерисовки графического окна с другими размерами осей и фигуры.
</p>
<p>Запустите программу на исполнение и убедитесь в том, что перемещение движка компонента <strong>TrackBar1</strong> вызывает изменение масштаба осей координат.
</p>
<p><strong>7.12. Разработка функции прорисовки фигуры ShowFig()</strong>
</p>
<p>Процесс прорисовки фигуры состоит из нескольких этапов. Сначала устанавливаем стиль пера и цвет фигуры. Затем преобразуем текущие отнормированные координаты фигуры в экранные. И только после этого выполняем собственно прорисовку: проводим линии от вершины <strong>A</strong> к вершине <strong>B</strong>, затем к вершине <strong>C</strong>, затем к вершине <strong>D</strong> и снова к <strong>A</strong>. После этого устанавливаем точки (маленькие окружности) в каждой из вершин фигуры. В заключение возвращаем свойствам пера исходные значения.
</p>
<p>void ShowFig(TColorcol, float matrT[4][3])
</p>
<p>{
</p>
<p> FBC-&gt;Pen-&gt;Color=col; // Устанавливаем цвет фигуры
</p>
<p> matrEkr[0][0]=W/2+int(h*matrT[0][0]); // Переводим координаты фигуры в экранные
</p>
<p> matrEkr[0][1]=H/2-int(h*matrT[0][1]);
</p>
<p> matrEkr[1][0]=W/2+int(h*matrT[1][0]);
</p>
<p> matrEkr[1][1]=H/2-int(h*matrT[1][1]);
</p>
<p>// и т.д., для всех восьми элементов матрицы matrEkr[4][2]
</p>
<p> FBC-&gt;MoveTo(matrEkr[0][0], matrEkr[0][1]); // Устанавливаем перо в "А"
</p>
<p> FBC-&gt;LineTo(matrEkr[1][0], matrEkr[1][1]); // Рисуем линию от "А" к "В"
</p>
<p> FBC-&gt;LineTo(matrEkr[2][0], matrEkr[2][1]); // Рисуем линию от "В" к "С"...
</p>
<p>// и т.д., для всех четырех вершин фигуры
</p>
<p> FBC-&gt;Ellipse(matrEkr[0][0]-2, matrEkr[0][1]-2,
</p>
<p> matrEkr[0][0]+2, matrEkr[0][1]+2); // Рисуем окружность в "А"
</p>
<p>// и т.д., для всех четырех вершин фигуры
</p>
<p> FBC-&gt;Pen-&gt;Color=clBlack; // Восстанавливаем исходные свойства пера
</p>
<p>}
</p>
<p>Снимаем заглушки с вызовов функций <strong>ShowFig()</strong> входящих в функцию <strong>ShowAll()</strong> и запускаем программу на исполнение. В графическом окне проекта должна прорисоваться исходная фигура в заданных исходных координатах с заданным цветом линий.
</p>
<p><strong>7.13. Разработка функции прорисовки обозначений Oboznath()</strong>
</p>
<p>Любая фигура, изображаемая на экране обладает, как минимум, двумя группами координат своих вершин. Первая группа – это её математические координаты, т.е. те, которые описывают местоположение фигуры в декартовой системе координат и хранятся в матрицах <strong>matrIsx[4][3]</strong> и <strong>matrRez[4][3]</strong> в виде вещественных чисел. Вторая группа координат – это экранные координаты фигуры, определяющие её физическое местоположение в графическом окне, и задаются в пикселях. Понятно, что математические координаты не совпадают с экранными, хотя они и описывают одно и то же место на экране. Поэтому, когда нам необходимо проставить буквенные обозначения с координатами возле каждой вершины мы должны придерживаться следующего правила: координаты возле вершин выводятся математические, а место, куда они проставляются, определяется в экранных координатах. Все эти особенности надо учитывать при заполнении списка фактических параметров для стандартной функции <strong>TextOut()</strong>, обеспечивающей вывод обозначений.
</p>
<p>Пример вывода обозначения для вершины <strong>А</strong> фигуры в формате <strong>А(x, y)</strong> имеет следующий вид:
</p>
<p>void Oboznath(float matrTo[4][3])
</p>
<p>{
</p>
<p> FBC-&gt;TextOut(W/2+int(h*matrTo[0][0]), H/2-int(h*matrTo[0][1])-20,
</p>
<p> "A("+FloatToStrF(matrTo[0][0], ffGeneral,2,1)+";"+
</p>
<p> FloatToStrF(matrTo[0][1], ffGeneral,2,1)+")");
</p>
<p>.//...и т.д., для остальных вершин: B, C, D
</p>
<p>}
</p>
<p>Как видно из текста программного кода функции <strong>ShowAll(), </strong> прорисовка обозначений осуществляется только в том случае, если включен флажок компонента <strong>CheckBox2.</strong> Для того, чтобы при переключении состояния флажка выполнялась прорисовка обозначений, или наоборот удалялась, необходимо создать обработчик события <strong>CheckBox2Click, </strong>с помощью которого можно вызывать команду <strong>FormPaint(0)</strong> для перерисовки графического окна. Порядок создания этого обработчика приведен в разделе 7.16.
</p>
<p>Снимаем заглушки с вызовов функций <strong>Oboznath()</strong> входящих в функцию <strong>ShowAll()</strong> и запускаем программу на исполнение. Теперь можно убедиться в том, что обозначения прорисовываются возле каждой из вершин фигуры после включения флажка компонента “<strong>Обозначения</strong>” и наоборот, исчезают после его выключения.
</p>
<p><strong>7.14. Создание обработчика события для кнопки "Запуск"</strong>
</p>
<p>Назначение обработчика события для кнопки "<strong>Запуск</strong>" (<strong>Button1) </strong> заключается в том, чтобы с его помощью запускать процессы преобразования и нормировки координат фигуры, а затем и прорисовки фигуры. Но, как уже говорилось выше, все эти действия запускаются не сразу, а через вызов функции перерисовки графического окна <strong>FormPaint()</strong>, внутри которой прописана функция графического конвейера <strong>GrafKonv()</strong>.
</p>
<p>Учитывая то, что мы задались целью выполнять видовые преобразования фигуры в режиме анимации, нам необходимо в состав обработчика <strong>Button1</strong> ввести оператор цикла <strong>For</strong>, из которого мы будем вызывать функцию <strong>FormPaint(0)</strong> много раз, в соответствии с требованиями анимации.
</p>
<p>Вообще, под анимацией понимается такое преобразование, при котором создается эффект плавного, непрерывного изменения положения фигуры или её размеров. Для этого все перемещение разбивается на множество маленьких перемещений, или шагов, и затем в цикле выполняют перерисовку фигуры столько раз, на сколько разбито полное перемещение (в нашем случае на 100 шагов). Чтобы не происходило суммирование ошибок вычисления, неизбежных при любых математических операциях, каждое пошаговое преобразование будем производить не относительно предыдущего положения фигуры, а относительно некоторого неизменного начального положения. Для этого у нас имеется матрица исходных координат фигуры <strong>matrIsx[4][3]</strong>. Далее, пересчитаем параметры матрицы преобразования<strong>Tpr[3][3]</strong> для одного шага анимации фигуры, т.е для 1/100 части от заданного отрезка перемещения. После этого можно вызывать функции <strong>Preobr(), Normir()</strong> и <strong>ShowAll()</strong>, входящие в состав графического конвейера, для перерисовки фигуры в цикле.
</p>
<p>Порядок создания функции обработки события <strong>Click</strong> для левой кнопки мыши аналогичен действиям, описанным в лаб. раб. №1. Необходимо дважды щелкнуть по кнопке "<strong>Пуск</strong>" (<strong>Button1)</strong> на конструкторе формы <strong>Form3</strong>. В окне редактора кода <strong>Unit3.cpp</strong>появится заголовок новой функции, внутри которой необходимо вписать команды, выполняющие следующие действия:
</p>
<p>- чтение значений параметров видового преобразования из ячеек компонента <strong>StringGrid2</strong>;
</p>
<p>- ввод этих значений в матрицу преобразования <strong>Tpr[3][3]</strong>;
</p>
<p>- формирование анимационного цикла, в котором выполняются следующие действия:
</p>
<p> - пересчет значений параметров матрицы преобразования <strong>Tpr[3][3]</strong> для их 1/100 части;
</p>
<p> - вызов перерисовки графического окна, для запуска графического конвейера;
</p>
<p> - вызов функции временно́й задержки <strong>Sleep(n)</strong>;
</p>
<p>- вывод значений матрицы координат преобразованной фигуры в ячейки компонента <strong>StringGrid3</strong>.
</p>
<p>С учетом вышесказанного, текст обработчика события для кнопки "<strong>Запуск</strong>" будет иметь вид:
</p>
<p>void __fastcall TForm3::Button1Click(TObject *Sender)
</p>
<p>{
</p>
<p> a=StrToFloat(Form3-&gt;StringGrid2-&gt;Cells[0][0]);
</p>
<p> b=StrToFloat(Form3-&gt;StringGrid2-&gt;Cells[1][0]);
</p>
<p> p=StrToFloat(Form3-&gt;StringGrid2-&gt;Cells[2][0]);
</p>
<p> d=StrToFloat(Form3-&gt;StringGrid2-&gt;Cells[0][1]);
</p>
<p> e=StrToFloat(Form3-&gt;StringGrid2-&gt;Cells[1][1]);
</p>
<p> q=StrToFloat(Form3-&gt;StringGrid2-&gt;Cells[2][1]);
</p>
<p> l=StrToFloat(Form3-&gt;StringGrid2-&gt;Cells[0][2]);
</p>
<p> m=StrToFloat(Form3-&gt;StringGrid2-&gt;Cells[1][2]);
</p>
<p> s=StrToFloat(Form3-&gt;StringGrid2-&gt;Cells[2][2]);
</p>
<p> Tpr[0][0]=a; Tpr[0][1]=b; Tpr[0][2]=p;
</p>
<p> Tpr[1][0]=d; Tpr[1][1]=e; Tpr[1][2]=q;
</p>
<p> Tpr[2][0]=l; Tpr[2][1]=m; Tpr[2][2]=s;
</p>
<p> if(Form3-&gt;CheckBox3-&gt;Checked)
</p>
<p> for(float i=0; i&lt;100; i++)
</p>
<p> {Tpr[0][0]=1+(((a-1)*(i+1))/100);
</p>
<p> Tpr[1][1]=1+(((e-1)*(i+1))/100);
</p>
<p> Tpr[2][0]=(i+1)*(l/100);
</p>
<p> Tpr[2][1]=(i+1)*(m/100);
</p>
<p> Tpr[2][2]=1+(((s-1)*(i+1))/100);
</p>
<p> FormPaint(0);
</p>
<p> Sleep(10);
</p>
<p> }
</p>
<p> else FormPaint(0);
</p>
<p> StringGrid3-&gt;Cells[0][0]=matrRez[0][0];
</p>
<p> StringGrid3-&gt;Cells[1][0]=matrRez[0][1];
</p>
<p> StringGrid3-&gt;Cells[2][0]=matrRez[0][2];
</p>
<p> StringGrid3-&gt;Cells[0][1]=matrRez[1][0];
</p>
<p> StringGrid3-&gt;Cells[1][1]=matrRez[1][1];
</p>
<p> StringGrid3-&gt;Cells[2][1]=matrRez[1][2];
</p>
<p> //ит.д., для остальных шести ячеек матрицы matrRez[4][3];
</p>
<p>}
</p>
<p>Как видно из текста этой программы, она позволяет выполнять анимацию только для переноса, масштабирования и отображения. Для осуществления анимации сдвига и перспективного проецирования необходимо разрабатывать гораздо более сложную функцию, так как там требуется пересчитывать каждую вершину по отдельности с использованием конвейера обработки изображения, и здесь мы это рассматривать не будем.
</p>
<p>Сохраните и запустите проект на исполнение.
</p>
<p>На рабочем поле открывшегося окна проекта, в ячейках компонента <strong>StringGrid2,</strong> установите параметры преобразования и щелкните мышью по кнопке "<strong>Пуск</strong>". В графическом окне, рядом с исходной фигурой <strong>ABCD</strong>, должна появиться вторая, преобразованная фигура. Местоположение и форма новой фигуры должны соответствовать заданным параметрам преобразования.
</p>
<p>Если перед нажатием на кнопку "<strong>Пуск</strong>" включить флажок компонента "<strong>Анимация</strong>", то преобразование фигуры должно происходить плавно, в замедленном режиме.
</p>
<p><strong>7.15. Создание обработчика события для кнопки "Исходное"</strong>
</p>
<p>Обработчик события кнопки "<strong>Исходное</strong>" (<strong>Button2)</strong> предназначен для следующих действий:
</p>
<p>- восстановления исходных значений матрицы видового преобразования <strong>Tpr[3][3]</strong>;
</p>
<p>- очистки всех ячеек компонентов <strong>StringGrid2</strong> и <strong>StringGrid3</strong>;
</p>
<p>- запуска функции перерисовки графического окна.
</p>
<p>Тогда текст его программного кода будет иметь вид:
</p>
<p>void __fastcall TForm3::Button2Click(TObject *Sender)
</p>
<p>{
</p>
<p> Tpr[0][0]=1; Tpr[0][1]=0; Tpr[0][2]=0;
</p>
<p> Tpr[1][0]=0; Tpr[1][1]=1; Tpr[1][2]=0;
</p>
<p> Tpr[2][0]=0; Tpr[2][1]=0; Tpr[2][2]=1;
</p>
<p> StringGrid2-&gt;Cells[0][0]=Tpr[0][0];
</p>
<p> StringGrid2-&gt;Cells[1][0]=Tpr[0][1];
</p>
<p> StringGrid2-&gt;Cells[2][0]=Tpr[0][2];
</p>
<p> // и т.д., для остальных шести ячеек компонента StringGrid2
</p>
<p> StringGrid3-&gt;Cells[0][0]=' ';
</p>
<p> StringGrid3-&gt;Cells[1][0]=' ';
</p>
<p> StringGrid3-&gt;Cells[2][0]=' ';
</p>
<p> StringGrid3-&gt;Cells[0][1]=' ';
</p>
<p> StringGrid3-&gt;Cells[1][1]=' ';
</p>
<p> StringGrid3-&gt;Cells[2][1]=' ';
</p>
<p> // и т.д., для остальных шести ячеек компонента StringGrid3
</p>
<p> FormPaint(0);
</p>
<p>}
</p>
<p>Здесь заполнение ячеек компонентов <strong>StringGrid</strong> конечно можно выполнить в цикле, что более предпочтительно для тех, кто считает себя настоящим программистом.
</p>
<p><strong>7.16. Создание обработчиков событий "Сетка" и "Обозначения"</strong>
</p>
<p>Необходимость создания обработчиков событий для этих компонентов заключается в том, чтобы вызывать перерисовку всего изображения в случае манипуляции пользователя с этими компонентами. При этом должен происходить перезапуск функции<strong>FormPaint(TObject *Sender)</strong> с помощью команды <strong>FormPaint(0)</strong>.
</p>
<p>Для создания обработчика для флажка "<strong>Сетка</strong>" дважды щелкните по объекту <strong>CheckBox1</strong> на конструкторе формы <strong>Form3</strong>. В окне редактора кода <strong>Unit3.cpp</strong> появится заголовок этой функции, внутри которой можно вписать команду вызова перерисовки графического окна:
</p>
<p>void __fastcall TForm3::CheckBox1Click(TObject *Sender)
</p>
<p>{
</p>
<p> FormPaint(0);
</p>
<p>}
</p>
<p>Аналогичный обработчик создайте для флажка "<strong>Обозначения</strong>" (<strong>CheckBox2)</strong>.
</p>
<p>На этом разработка файла реализации для лабораторной работы №2 заканчивается. Сохраните проект и запустите на исполнение для проверки его работоспособности при выполнении видовых преобразований над фигурой.
</p>
  
  </div>
</body>
</html>
